
    export default [
      "@league-of-foundry-developers/foundry-vtt-types/src/foundry/foundry.js/rollTerms/poolTerm.d.ts",
      "declare global {\n  /**\n   * A type of RollTerm which encloses a pool of multiple inner Rolls which are evaluated jointly.\n   *\n   * A dice pool represents a set of Roll expressions which are collectively modified to compute an effective total\n   * across all Rolls in the pool. The final total for the pool is defined as the sum over kept rolls, relative to any\n   * success count or margin.\n   *\n   * @example\n   * ```typescript\n   * // Keep the highest of the 3 roll expressions\n   * let pool = new PoolTerm({\n   *   rolls: [\"4d6\", \"3d8 - 1\", \"2d10 + 3\"],\n   *   modifiers: [\"kh\"]\n   * });\n   * pool.evaluate();\n   * ```\n   */\n  class PoolTerm extends RollTerm {\n    constructor({ terms, modifiers, rolls, results, options }?: PoolTermConstructorData);\n\n    /**\n     * The original provided terms to the Dice Pool\n     */\n    terms: PoolTerm.TermData['terms'];\n\n    /**\n     * The string modifiers applied to resolve the pool\n     */\n    modifiers: PoolTerm.TermData['modifiers'];\n\n    /**\n     * Each component term of a dice pool is evaluated as a Roll instance\n     */\n    rolls: PoolTerm.TermData['rolls'];\n\n    /**\n     * The array of dice pool results which have been rolled\n     */\n    results: PoolTerm.TermData['results'];\n\n    /**\n     * Define the modifiers that can be used for this particular DiceTerm type.\n     */\n    static MODIFIERS: PoolTerm.Modifiers;\n\n    /**\n     * The regular expression pattern used to identify the opening of a dice pool expression.\n     * @defaultValue `/{/g`\n     */\n    static OPEN_REGEXP: RegExp;\n\n    /**\n     * A regular expression pattern used to identify the closing of a dice pool expression\n     * @defaultValue\n     * ```typescript\n     * new RegExp(`}${DiceTerm.MODIFIERS_REGEXP_STRING}?(?:%F[0-9]+%)?`, \"g\")\n     * ```\n     */\n    static CLOSE_REGEXP: RegExp;\n\n    /**\n     * @defaultValue `[\"terms\", \"modifiers\", \"rolls\", \"results\"]`\n     */\n    static SERIALIZE_ATTRIBUTES: string[];\n\n    /**\n     * Return an Array of each individual DiceTerm instances contained within the PoolTerm.\n     */\n    get dice(): DiceTerm[];\n\n    get expression(): string;\n\n    get total(): undefined | number;\n\n    /**\n     * Return an array of rolled values which are still active within the PoolTerm\n     */\n    get values(): number[];\n\n    /**\n     * Alter the DiceTerm by adding or multiplying the number of dice which are rolled\n     * @param args - Arguments passed to each contained Roll#alter method.\n     * @returns The altered pool\n     */\n    alter(...args: Parameters<Roll['alter']>): this;\n\n    protected _evaluateSync({ minimize, maximize }?: { minimize?: boolean; maximize?: boolean }): this;\n\n    protected _evaluate({ minimize, maximize }?: { minimize?: boolean; maximize?: boolean }): Promise<this>;\n\n    /**\n     * Use the same logic as for the DiceTerm to avoid duplication\n     * @see DiceTerm#_evaluateModifiers\n     */\n    protected _evaluateModifiers(): void;\n\n    /**\n     * Use the same logic as for the DiceTerm to avoid duplication\n     * @see DiceTerm#_evaluateModifier\n     */\n    protected _evaluateModifier(command: string, modifier: string): void;\n\n    protected static _fromData<T extends RollTerm>(this: ConstructorOf<T>, data: object): T;\n\n    toJSON(): object;\n\n    /**\n     * Given a string formula, create and return an evaluated PoolTerm object\n     * @param formula - The string formula to parse\n     * @param options - Additional options applied to the PoolTerm\n     * @returns The evaluated PoolTerm object or null if the formula is invalid\n     */\n    static fromExpression<T extends RollTerm>(\n      this: ConstructorOf<T>,\n      formula: string,\n      options?: RollTerm.Options\n    ): T | null;\n\n    /**\n     * Create a PoolTerm by providing an array of existing Roll objects\n     * @param rolls - An array of Roll objects from which to create the pool\n     * @returns The constructed PoolTerm comprised of the provided rolls\n     */\n    static fromRolls<T extends PoolTerm>(this: ConstructorOf<T>, rolls?: Roll[]): T;\n\n    /**\n     * Keep a certain number of highest or lowest dice rolls from the result set.\n     * @example\n     * `{1d6,1d8,1d10,1d12}kh2` Keep the 2 best rolls from the pool\n     * @example\n     * `{1d12,6}kl` Keep the lowest result in the pool\n     *\n     * @param modifier - The matched modifier query\n     */\n    keep(modifier: string): ReturnType<Die['keep']>;\n\n    /**\n     * Keep a certain number of highest or lowest dice rolls from the result set.\n     * @example\n     * `{1d6,1d8,1d10,1d12}dl3` Drop the 3 worst results in the pool\n     * @example\n     * `{1d12,6}dh` Drop the highest result in the pool\n     *\n     * @param modifier - The matched modifier query\n     */\n    drop(modifier: string): ReturnType<Die['drop']>;\n\n    /**\n     * Count the number of successful results which occurred in the pool.\n     * Successes are counted relative to some target, or relative to the maximum possible value if no target is given.\n     * Applying a count-success modifier to the results re-casts all results to 1 (success) or 0 (failure)\n     * @example\n     * `20d20cs` Count the number of dice which rolled a 20\n     * @example\n     * `20d20cs>10` Count the number of dice which rolled higher than 10\n     * @example\n     * `20d20cs<10` Count the number of dice which rolled less than 10\n     *\n     * @param modifier - The matched modifier query\n     */\n    countSuccess(modifier: string): ReturnType<Die['countSuccess']>;\n\n    /**\n     * Count the number of failed results which occurred in a given result set.\n     * Failures are counted relative to some target, or relative to the lowest possible value if no target is given.\n     * Applying a count-failures modifier to the results re-casts all results to 1 (failure) or 0 (non-failure)\n     * @example\n     * `6d6cf` Count the number of dice which rolled a 1 as failures\n     * @example\n     * `6d6cf<=3` Count the number of dice which rolled less than 3 as failures\n     * @example\n     * `6d6cf>4` Count the number of dice which rolled greater than 4 as failures\n     *\n     * @param modifier - The matched modifier query\n     */\n    countFailures(modifier: string): ReturnType<Die['countFailures']>;\n  }\n\n  /**\n   * @deprecated since 0.8.1\n   */\n  const DicePool: typeof PoolTerm;\n\n  namespace PoolTerm {\n    /**\n     * @remarks This interface is not defined by foundry itself. It only exists\n     * to allow module and system authors to use it for declaration merging,\n     * enabling them to add additional modifiers for {@link PoolTerm}s.\n     */\n    interface Modifiers {\n      k: 'keep';\n      kh: 'keep';\n      kl: 'keep';\n      d: 'drop';\n      dh: 'drop';\n      dl: 'drop';\n      cs: 'countSuccess';\n      cf: 'countFailures';\n    }\n\n    type TermData = Required<PoolTermConstructorData>;\n  }\n}\n\ninterface PoolTermConstructorData {\n  /**\n   * @defaultValue `[]`\n   */\n  terms?: string[];\n\n  /**\n   * @defaultValue `[]`\n   */\n  modifiers?: string[];\n\n  /**\n   * @defaultValue `[]`\n   */\n  rolls?: Roll[];\n\n  /**\n   * @defaultValue `[]`\n   */\n  results?: DiceTerm.Result[];\n\n  /**\n   * @defaultValue `{}`\n   */\n  options?: RollTerm.Options;\n}\n\nexport {};\n"
    ]
  