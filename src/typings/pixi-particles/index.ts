
    export default [
      "pixi-particles/index.d.ts",
      "// Generated by dts-bundle-generator v4.3.0\n\nimport { Circle, Container, DisplayObject, Point, Rectangle, Renderer, Sprite, Texture } from 'pixi.js';\n\nexport interface BasicPoint {\r\n\tx: number;\r\n\ty: number;\r\n}\nexport interface Segment {\r\n\tp1: BasicPoint;\r\n\tp2: BasicPoint;\r\n\tl: number;\r\n}\n/**\r\n * Chain of line segments for generating spawn positions.\r\n */\nexport declare class PolygonalChain {\r\n\t/**\r\n\t * List of segment objects in the chain.\r\n\t */\r\n\tprivate segments;\r\n\t/**\r\n\t * Total length of all segments of the chain.\r\n\t */\r\n\tprivate totalLength;\r\n\t/**\r\n\t * Total length of segments up to and including the segment of the same index.\r\n\t * Used for weighted random selection of segment.\r\n\t */\r\n\tprivate countingLengths;\r\n\t/**\r\n\t * @param data Point data for polygon chains. Either a list of points for a single chain, or a list of chains.\r\n\t */\r\n\tconstructor(data: BasicPoint[] | BasicPoint[][]);\r\n\t/**\r\n\t * @param data Point data for polygon chains. Either a list of points for a single chain, or a list of chains.\r\n\t */\r\n\tprivate init;\r\n\t/**\r\n\t * Gets a random point in the chain.\r\n\t * @param out The point to store the selected position in.\r\n\t */\r\n\tgetRandomPoint(out: Point): void;\r\n}\nexport interface EmitterConfig {\r\n\talpha?: ValueList<number>;\r\n\tspeed?: ValueList<number>;\r\n\tminimumSpeedMultiplier?: number;\r\n\tmaxSpeed?: number;\r\n\tacceleration?: {\r\n\t\tx: number;\r\n\t\ty: number;\r\n\t};\r\n\tscale?: ValueList<number>;\r\n\tminimumScaleMultiplier?: number;\r\n\tcolor?: ValueList<string>;\r\n\tstartRotation?: RandNumber;\r\n\tnoRotation?: boolean;\r\n\trotationSpeed?: RandNumber;\r\n\trotationAcceleration?: number;\r\n\tlifetime: RandNumber;\r\n\tblendMode?: string;\r\n\tease?: SimpleEase | EaseSegment[];\r\n\textraData?: any;\r\n\tparticlesPerWave?: number;\r\n\t/**\r\n\t * Really \"rect\"|\"circle\"|\"ring\"|\"burst\"|\"point\"|\"polygonalChain\", but that\r\n\t * tends to be too strict for random object creation.\r\n\t */\r\n\tspawnType?: string;\r\n\tspawnRect?: {\r\n\t\tx: number;\r\n\t\ty: number;\r\n\t\tw: number;\r\n\t\th: number;\r\n\t};\r\n\tspawnCircle?: {\r\n\t\tx: number;\r\n\t\ty: number;\r\n\t\tr: number;\r\n\t\tminR?: number;\r\n\t};\r\n\tparticleSpacing?: number;\r\n\tangleStart?: number;\r\n\tspawnPolygon?: BasicPoint[] | BasicPoint[][];\r\n\tfrequency: number;\r\n\tspawnChance?: number;\r\n\temitterLifetime?: number;\r\n\tmaxParticles?: number;\r\n\taddAtBack?: boolean;\r\n\tpos: {\r\n\t\tx: number;\r\n\t\ty: number;\r\n\t};\r\n\temit?: boolean;\r\n\tautoUpdate?: boolean;\r\n\torderedArt?: boolean;\r\n}\nexport interface RandNumber {\r\n\tmax: number;\r\n\tmin: number;\r\n}\nexport interface BasicTweenable<T> {\r\n\tstart: T;\r\n\tend: T;\r\n}\nexport interface OldEmitterConfig {\r\n\talpha?: BasicTweenable<number>;\r\n\tspeed?: BasicTweenable<number> & {\r\n\t\tminimumSpeedMultiplier?: number;\r\n\t};\r\n\tmaxSpeed?: number;\r\n\tacceleration?: {\r\n\t\tx: number;\r\n\t\ty: number;\r\n\t};\r\n\tscale?: BasicTweenable<number> & {\r\n\t\tminimumScaleMultiplier?: number;\r\n\t};\r\n\tcolor?: BasicTweenable<string>;\r\n\tstartRotation?: RandNumber;\r\n\tnoRotation?: boolean;\r\n\trotationSpeed?: RandNumber;\r\n\trotationAcceleration?: number;\r\n\tlifetime: RandNumber;\r\n\tblendMode?: string;\r\n\tease?: SimpleEase | EaseSegment[];\r\n\textraData?: any;\r\n\tparticlesPerWave?: number;\r\n\t/**\r\n\t * Really \"rect\"|\"circle\"|\"ring\"|\"burst\"|\"point\"|\"polygonalChain\", but that\r\n\t * tends to be too strict for random object creation.\r\n\t */\r\n\tspawnType?: string;\r\n\tspawnRect?: {\r\n\t\tx: number;\r\n\t\ty: number;\r\n\t\tw: number;\r\n\t\th: number;\r\n\t};\r\n\tspawnCircle?: {\r\n\t\tx: number;\r\n\t\ty: number;\r\n\t\tr: number;\r\n\t\tminR?: number;\r\n\t};\r\n\tparticleSpacing?: number;\r\n\tangleStart?: number;\r\n\tspawnPolygon?: BasicPoint[] | BasicPoint[][];\r\n\tfrequency: number;\r\n\tspawnChance?: number;\r\n\temitterLifetime?: number;\r\n\tmaxParticles?: number;\r\n\taddAtBack?: boolean;\r\n\tpos: {\r\n\t\tx: number;\r\n\t\ty: number;\r\n\t};\r\n\temit?: boolean;\r\n\tautoUpdate?: boolean;\r\n\torderedArt?: boolean;\r\n}\nexport interface ValueStep<T> {\r\n\tvalue: T;\r\n\ttime: number;\r\n}\nexport interface ValueList<T> {\r\n\tlist: ValueStep<T>[];\r\n\tisStepped?: boolean;\r\n\tease?: SimpleEase | EaseSegment[];\r\n}\n/**\r\n * A single node in a PropertyList.\r\n */\nexport declare class PropertyNode<V> {\r\n\t/**\r\n\t * Value for the node.\r\n\t */\r\n\tvalue: V;\r\n\t/**\r\n\t * Time value for the node. Between 0-1.\r\n\t */\r\n\ttime: number;\r\n\t/**\r\n\t * The next node in line.\r\n\t */\r\n\tnext: PropertyNode<V>;\r\n\t/**\r\n\t * If this is the first node in the list, controls if the entire list is stepped or not.\r\n\t */\r\n\tisStepped: boolean;\r\n\tease: SimpleEase;\r\n\t/**\r\n\t * @param value The value for this node\r\n\t * @param time The time for this node, between 0-1\r\n\t * @param [ease] Custom ease for this list. Only relevant for the first node.\r\n\t */\r\n\tconstructor(value: V, time: number, ease?: SimpleEase | EaseSegment[]);\r\n\t/**\r\n\t * Creates a list of property values from a data object {list, isStepped} with a list of objects in\r\n\t * the form {value, time}. Alternatively, the data object can be in the deprecated form of\r\n\t * {start, end}.\r\n\t * @param data The data for the list.\r\n\t * @param data.list The array of value and time objects.\r\n\t * @param data.isStepped If the list is stepped rather than interpolated.\r\n\t * @param data.ease Custom ease for this list.\r\n\t * @return The first node in the list\r\n\t */\r\n\tstatic createList<T extends (string | number)>(data: ValueList<T> | BasicTweenable<T>): PropertyNode<T extends string ? Color : T>;\r\n}\nexport declare function GetTextureFromString(s: string): Texture;\nexport interface Color {\r\n\tr: number;\r\n\tg: number;\r\n\tb: number;\r\n\ta?: number;\r\n}\nexport interface EaseSegment {\r\n\tcp: number;\r\n\ts: number;\r\n\te: number;\r\n}\nexport declare type SimpleEase = (time: number) => number;\n/**\r\n * Contains helper functions for particles and emitters to use.\r\n */\nexport declare namespace ParticleUtils {\r\n\t/**\r\n\t * If errors and warnings should be logged within the library.\r\n\t */\r\n\tconst verbose = false;\r\n\tconst DEG_TO_RADS: number;\r\n\t/**\r\n\t * Rotates a point by a given angle.\r\n\t * @param angle The angle to rotate by in degrees\r\n\t * @param p The point to rotate around 0,0.\r\n\t */\r\n\tfunction rotatePoint(angle: number, p: Point): void;\r\n\t/**\r\n\t * Combines separate color components (0-255) into a single uint color.\r\n\t * @param r The red value of the color\r\n\t * @param g The green value of the color\r\n\t * @param b The blue value of the color\r\n\t * @return The color in the form of 0xRRGGBB\r\n\t */\r\n\tfunction combineRGBComponents(r: number, g: number, b: number): number;\r\n\t/**\r\n\t * Reduces the point to a length of 1.\r\n\t * @param point The point to normalize\r\n\t */\r\n\tfunction normalize(point: Point): void;\r\n\t/**\r\n\t * Multiplies the x and y values of this point by a value.\r\n\t * @param point The point to scaleBy\r\n\t * @param value The value to scale by.\r\n\t */\r\n\tfunction scaleBy(point: Point, value: number): void;\r\n\t/**\r\n\t * Returns the length (or magnitude) of this point.\r\n\t * @param point The point to measure length\r\n\t * @return The length of this point.\r\n\t */\r\n\tfunction length(point: Point): number;\r\n\t/**\r\n\t * Converts a hex string from \"#AARRGGBB\", \"#RRGGBB\", \"0xAARRGGBB\", \"0xRRGGBB\",\r\n\t * \"AARRGGBB\", or \"RRGGBB\" to an object of ints of 0-255, as\r\n\t * {r, g, b, (a)}.\r\n\t * @param color The input color string.\r\n\t * @param output An object to put the output in. If omitted, a new object is created.\r\n\t * @return The object with r, g, and b properties, possibly with an a property.\r\n\t */\r\n\tfunction hexToRGB(color: string, output?: Color): Color;\r\n\t/**\r\n\t * Generates a custom ease function, based on the GreenSock custom ease, as demonstrated\r\n\t * by the related tool at http://www.greensock.com/customease/.\r\n\t * @param segments An array of segments, as created by\r\n\t * http://www.greensock.com/customease/.\r\n\t * @return A function that calculates the percentage of change at\r\n\t *                    a given point in time (0-1 inclusive).\r\n\t */\r\n\tfunction generateEase(segments: EaseSegment[]): SimpleEase;\r\n\t/**\r\n\t * Gets a blend mode, ensuring that it is valid.\r\n\t * @param name The name of the blend mode to get.\r\n\t * @return The blend mode as specified in the PIXI.BLEND_MODES enumeration.\r\n\t */\r\n\tfunction getBlendMode(name: string): number;\r\n\t/**\r\n\t * Converts a list of {value, time} objects starting at time 0 and ending at time 1 into an evenly\r\n\t * spaced stepped list of PropertyNodes for color values. This is primarily to handle conversion of\r\n\t * linear gradients to fewer colors, allowing for some optimization for Canvas2d fallbacks.\r\n\t * @param list The list of data to convert.\r\n\t * @param [numSteps=10] The number of steps to use.\r\n\t * @return The blend mode as specified in the PIXI.blendModes enumeration.\r\n\t */\r\n\tfunction createSteppedGradient(list: ValueStep<string>[], numSteps?: number): PropertyNode<Color>;\r\n}\nexport interface ParticleConstructor {\r\n\tnew (emitter: Emitter): Particle;\r\n}\n/**\r\n * A particle emitter.\r\n */\nexport declare class Emitter {\r\n\t/**\r\n\t * The constructor used to create new particles. The default is\r\n\t * the built in particle class.\r\n\t */\r\n\tprotected _particleConstructor: typeof Particle;\r\n\t/**\r\n\t * An array of PIXI Texture objects.\r\n\t */\r\n\tparticleImages: any[];\r\n\t/**\r\n\t * The first node in the list of alpha values for all particles.\r\n\t */\r\n\tstartAlpha: PropertyNode<number>;\r\n\t/**\r\n\t * The first node in the list of speed values of all particles.\r\n\t */\r\n\tstartSpeed: PropertyNode<number>;\r\n\t/**\r\n\t * A minimum multiplier for the speed of a particle at all stages of its life. A value between\r\n\t * minimumSpeedMultiplier and 1 is randomly generated for each particle.\r\n\t */\r\n\tminimumSpeedMultiplier: number;\r\n\t/**\r\n\t * Acceleration to apply to particles. Using this disables\r\n\t * any interpolation of particle speed. If the particles do\r\n\t * not have a rotation speed, then they will be rotated to\r\n\t * match the direction of travel.\r\n\t */\r\n\tacceleration: Point;\r\n\t/**\r\n\t * The maximum speed allowed for accelerating particles. Negative values, values of 0 or NaN\r\n\t * will disable the maximum speed.\r\n\t */\r\n\tmaxSpeed: number;\r\n\t/**\r\n\t * The first node in the list of scale values of all particles.\r\n\t */\r\n\tstartScale: PropertyNode<number>;\r\n\t/**\r\n\t * A minimum multiplier for the scale of a particle at all stages of its life. A value between\r\n\t * minimumScaleMultiplier and 1 is randomly generated for each particle.\r\n\t */\r\n\tminimumScaleMultiplier: number;\r\n\t/**\r\n\t * The first node in the list of  color values of all particles, as red, green, and blue\r\n\t * uints from 0-255.\r\n\t */\r\n\tstartColor: PropertyNode<Color>;\r\n\t/**\r\n\t * The minimum lifetime for a particle, in seconds.\r\n\t */\r\n\tminLifetime: number;\r\n\t/**\r\n\t * The maximum lifetime for a particle, in seconds.\r\n\t */\r\n\tmaxLifetime: number;\r\n\t/**\r\n\t * The minimum start rotation for a particle, in degrees. This value\r\n\t * is ignored if the spawn type is \"burst\" or \"arc\".\r\n\t */\r\n\tminStartRotation: number;\r\n\t/**\r\n\t * The maximum start rotation for a particle, in degrees. This value\r\n\t * is ignored if the spawn type is \"burst\" or \"arc\".\r\n\t */\r\n\tmaxStartRotation: number;\r\n\t/**\r\n\t * If no particle rotation should occur. Starting rotation will still\r\n\t * affect the direction in which particles move. If the rotation speed\r\n\t * is set, then this will be ignored.\r\n\t */\r\n\tnoRotation: boolean;\r\n\t/**\r\n\t * The minimum rotation speed for a particle, in degrees per second.\r\n\t * This only visually spins the particle, it does not change direction\r\n\t * of movement.\r\n\t */\r\n\tminRotationSpeed: number;\r\n\t/**\r\n\t * The maximum rotation speed for a particle, in degrees per second.\r\n\t * This only visually spins the particle, it does not change direction\r\n\t * of movement.\r\n\t */\r\n\tmaxRotationSpeed: number;\r\n\t/**\r\n\t* The Acceleration of rotation (angular acceleration) for a particle, in degrees per second.\r\n\t*/\r\n\trotationAcceleration: number;\r\n\t/**\r\n\t * The blend mode for all particles, as named by PIXI.blendModes.\r\n\t */\r\n\tparticleBlendMode: number;\r\n\t/**\r\n\t * An easing function for nonlinear interpolation of values. Accepts a single\r\n\t * parameter of time as a value from 0-1, inclusive. Expected outputs are values\r\n\t * from 0-1, inclusive.\r\n\t */\r\n\tcustomEase: SimpleEase;\r\n\t/**\r\n\t *\tExtra data for use in custom particles. The emitter doesn't look inside, but\r\n\t *\tpasses it on to the particle to use in init().\r\n\t */\r\n\textraData: any;\r\n\t/**\r\n\t * Time between particle spawns in seconds.\r\n\t */\r\n\tprotected _frequency: number;\r\n\t/**\r\n\t * Chance that a particle will be spawned on each opportunity to spawn one.\r\n\t * 0 is 0%, 1 is 100%.\r\n\t */\r\n\tspawnChance: number;\r\n\t/**\r\n\t * Maximum number of particles to keep alive at a time. If this limit\r\n\t * is reached, no more particles will spawn until some have died.\r\n\t */\r\n\tmaxParticles: number;\r\n\t/**\r\n\t * The amount of time in seconds to emit for before setting emit to false.\r\n\t * A value of -1 is an unlimited amount of time.\r\n\t */\r\n\temitterLifetime: number;\r\n\t/**\r\n\t * Position at which to spawn particles, relative to the emitter's owner's origin.\r\n\t * For example, the flames of a rocket travelling right might have a spawnPos\r\n\t * of {x:-50, y:0}.\r\n\t * to spawn at the rear of the rocket.\r\n\t * To change this, use updateSpawnPos().\r\n\t */\r\n\tspawnPos: Point;\r\n\t/**\r\n\t * How the particles will be spawned. Valid types are \"point\", \"rectangle\",\r\n\t * \"circle\", \"burst\", \"ring\".\r\n\t */\r\n\tspawnType: string;\r\n\t/**\r\n\t * A reference to the emitter function specific to the spawn type.\r\n\t */\r\n\tprotected _spawnFunc: (p: Particle, emitPosX: number, emitPosY: number, i?: number) => void;\r\n\t/**\r\n\t * A rectangle relative to spawnPos to spawn particles inside if the spawn type is \"rect\".\r\n\t */\r\n\tspawnRect: Rectangle;\r\n\t/**\r\n\t * A polygon relative to spawnPos to spawn particles on the chain if the spawn type is \"polygonalChain\".\r\n\t */\r\n\tspawnPolygonalChain: PolygonalChain;\r\n\t/**\r\n\t * A circle relative to spawnPos to spawn particles inside if the spawn type is \"circle\".\r\n\t */\r\n\tspawnCircle: Circle & {\r\n\t\tminRadius: number;\r\n\t};\r\n\t/**\r\n\t * Number of particles to spawn time that the frequency allows for particles to spawn.\r\n\t */\r\n\tparticlesPerWave: number;\r\n\t/**\r\n\t * Spacing between particles in a burst. 0 gives a random angle for each particle.\r\n\t */\r\n\tparticleSpacing: number;\r\n\t/**\r\n\t * Angle at which to start spawning particles in a burst.\r\n\t */\r\n\tangleStart: number;\r\n\t/**\r\n\t * Rotation of the emitter or emitter's owner in degrees. This is added to\r\n\t * the calculated spawn angle.\r\n\t * To change this, use rotate().\r\n\t */\r\n\tprotected rotation: number;\r\n\t/**\r\n\t * The world position of the emitter's owner, to add spawnPos to when\r\n\t * spawning particles. To change this, use updateOwnerPos().\r\n\t */\r\n\tprotected ownerPos: Point;\r\n\t/**\r\n\t * The origin + spawnPos in the previous update, so that the spawn position\r\n\t * can be interpolated to space out particles better.\r\n\t */\r\n\tprotected _prevEmitterPos: Point;\r\n\t/**\r\n\t * If _prevEmitterPos is valid, to prevent interpolation on the first update\r\n\t */\r\n\tprotected _prevPosIsValid: boolean;\r\n\t/**\r\n\t * If either ownerPos or spawnPos has changed since the previous update.\r\n\t */\r\n\tprotected _posChanged: boolean;\r\n\t/**\r\n\t * The container to add particles to.\r\n\t */\r\n\tprotected _parent: Container;\r\n\t/**\r\n\t * If particles should be added at the back of the display list instead of the front.\r\n\t */\r\n\taddAtBack: boolean;\r\n\t/**\r\n\t * The current number of active particles.\r\n\t */\r\n\tparticleCount: number;\r\n\t/**\r\n\t * If particles should be emitted during update() calls. Setting this to false\r\n\t * stops new particles from being created, but allows existing ones to die out.\r\n\t */\r\n\tprotected _emit: boolean;\r\n\t/**\r\n\t * The timer for when to spawn particles in seconds, where numbers less\r\n\t * than 0 mean that particles should be spawned.\r\n\t */\r\n\tprotected _spawnTimer: number;\r\n\t/**\r\n\t * The life of the emitter in seconds.\r\n\t */\r\n\tprotected _emitterLife: number;\r\n\t/**\r\n\t * The particles that are active and on the display list. This is the first particle in a\r\n\t * linked list.\r\n\t */\r\n\tprotected _activeParticlesFirst: Particle;\r\n\t/**\r\n\t * The particles that are active and on the display list. This is the last particle in a\r\n\t * linked list.\r\n\t */\r\n\tprotected _activeParticlesLast: Particle;\r\n\t/**\r\n\t * The particles that are not currently being used. This is the first particle in a\r\n\t * linked list.\r\n\t */\r\n\tprotected _poolFirst: Particle;\r\n\t/**\r\n\t * The original config object that this emitter was initialized with.\r\n\t */\r\n\tprotected _origConfig: any;\r\n\t/**\r\n\t * The original particle image data that this emitter was initialized with.\r\n\t */\r\n\tprotected _origArt: any;\r\n\t/**\r\n\t * If the update function is called automatically from the shared ticker.\r\n\t * Setting this to false requires calling the update function manually.\r\n\t */\r\n\tprotected _autoUpdate: boolean;\r\n\t/**\r\n\t * A number keeping index of currently applied image. Used to emit arts in order.\r\n\t */\r\n\tprotected _currentImageIndex: number;\r\n\t/**\r\n\t * If the emitter should destroy itself when all particles have died out. This is set by\r\n\t * playOnceAndDestroy();\r\n\t */\r\n\tprotected _destroyWhenComplete: boolean;\r\n\t/**\r\n\t * A callback for when all particles have died out. This is set by\r\n\t * playOnceAndDestroy() or playOnce();\r\n\t */\r\n\tprotected _completeCallback: () => void;\r\n\t/**\r\n\t * @param particleParent The container to add the particles to.\r\n\t * @param particleImages A texture or array of textures to use\r\n\t *                       for the particles. Strings will be turned\r\n\t *                       into textures via Texture.fromImage().\r\n\t * @param config A configuration object containing settings for the emitter.\r\n\t * @param config.emit If config.emit is explicitly passed as false, the\r\n\t *                    Emitter will start disabled.\r\n\t * @param config.autoUpdate If config.autoUpdate is explicitly passed as\r\n\t *                          true, the Emitter will automatically call\r\n\t *                          update via the PIXI shared ticker.\r\n\t */\r\n\tconstructor(particleParent: Container, particleImages: any, config: EmitterConfig | OldEmitterConfig);\r\n\t/**\r\n\t * If the emitter is using particle art in order as provided in `particleImages`.\r\n\t * Effective only when `particleImages` has multiple art options.\r\n\t * This is particularly useful ensuring that each art shows up once, in case you need to emit a body in an order.\r\n\t * For example: dragon - [Head, body1, body2, ..., tail]\r\n\t */\r\n\torderedArt: boolean;\r\n\t/**\r\n\t * Time between particle spawns in seconds. If this value is not a number greater than 0,\r\n\t * it will be set to 1 (particle per second) to prevent infinite loops.\r\n\t */\r\n\tfrequency: number;\r\n\t/**\r\n\t * The constructor used to create new particles. The default is\r\n\t * the built in Particle class. Setting this will dump any active or\r\n\t * pooled particles, if the emitter has already been used.\r\n\t */\r\n\tparticleConstructor: typeof Particle;\r\n\t/**\r\n\t* The container to add particles to. Settings this will dump any active particles.\r\n\t*/\r\n\tparent: Container;\r\n\t/**\r\n\t * Sets up the emitter based on the config settings.\r\n\t * @param art A texture or array of textures to use for the particles.\r\n\t * @param config A configuration object containing settings for the emitter.\r\n\t */\r\n\tinit(art: any, config: EmitterConfig | OldEmitterConfig): void;\r\n\t/**\r\n\t * Sets up additional parameters to the emitter from config settings.\r\n\t * Using for parsing additional parameters on classes that extend from Emitter\r\n\t * @param art A texture or array of textures to use for the particles.\r\n\t * @param config A configuration object containing settings for the emitter.\r\n\t */\r\n\tprotected initAdditional(art: any, config: EmitterConfig | OldEmitterConfig): void;\r\n\t/**\r\n\t * Parsing emitter spawn type from config settings.\r\n\t * Place for override and add new kind of spawn type\r\n\t * @param config A configuration object containing settings for the emitter.\r\n\t */\r\n\tprotected parseSpawnType(config: EmitterConfig | OldEmitterConfig): void;\r\n\t/**\r\n\t * Recycles an individual particle. For internal use only.\r\n\t * @param particle The particle to recycle.\r\n\t * @internal\r\n\t */\r\n\trecycle(particle: Particle): void;\r\n\t/**\r\n\t * Sets the rotation of the emitter to a new value.\r\n\t * @param newRot The new rotation, in degrees.\r\n\t */\r\n\trotate(newRot: number): void;\r\n\t/**\r\n\t * Changes the spawn position of the emitter.\r\n\t * @param x The new x value of the spawn position for the emitter.\r\n\t * @param y The new y value of the spawn position for the emitter.\r\n\t */\r\n\tupdateSpawnPos(x: number, y: number): void;\r\n\t/**\r\n\t * Changes the position of the emitter's owner. You should call this if you are adding\r\n\t * particles to the world container that your emitter's owner is moving around in.\r\n\t * @param x The new x value of the emitter's owner.\r\n\t * @param y The new y value of the emitter's owner.\r\n\t */\r\n\tupdateOwnerPos(x: number, y: number): void;\r\n\t/**\r\n\t * Prevents emitter position interpolation in the next update.\r\n\t * This should be used if you made a major position change of your emitter's owner\r\n\t * that was not normal movement.\r\n\t */\r\n\tresetPositionTracking(): void;\r\n\t/**\r\n\t * If particles should be emitted during update() calls. Setting this to false\r\n\t * stops new particles from being created, but allows existing ones to die out.\r\n\t */\r\n\temit: boolean;\r\n\t/**\r\n\t * If the update function is called automatically from the shared ticker.\r\n\t * Setting this to false requires calling the update function manually.\r\n\t */\r\n\tautoUpdate: boolean;\r\n\t/**\r\n\t * Starts emitting particles, sets autoUpdate to true, and sets up the Emitter to destroy itself\r\n\t * when particle emission is complete.\r\n\t * @param callback Callback for when emission is complete (all particles have died off)\r\n\t */\r\n\tplayOnceAndDestroy(callback?: () => void): void;\r\n\t/**\r\n\t * Starts emitting particles and optionally calls a callback when particle emission is complete.\r\n\t * @param callback Callback for when emission is complete (all particles have died off)\r\n\t */\r\n\tplayOnce(callback?: () => void): void;\r\n\t/**\r\n\t * Updates all particles spawned by this emitter and emits new ones.\r\n\t * @param delta Time elapsed since the previous frame, in __seconds__.\r\n\t */\r\n\tupdate(delta: number): void;\r\n\t/**\r\n\t * Set additional properties to new particle.\r\n\t * Using on classes that extend from Emitter\r\n\t * @param p The particle\r\n\t */\r\n\tprotected applyAdditionalProperties(p: Particle): void;\r\n\t/**\r\n\t * Positions a particle for a point type emitter.\r\n\t * @param p The particle to position and rotate.\r\n\t * @param emitPosX The emitter's x position\r\n\t * @param emitPosY The emitter's y position\r\n\t * @param i The particle number in the current wave. Not used for this function.\r\n\t */\r\n\tprotected _spawnPoint(p: Particle, emitPosX: number, emitPosY: number): void;\r\n\t/**\r\n\t * Positions a particle for a rectangle type emitter.\r\n\t * @param p The particle to position and rotate.\r\n\t * @param emitPosX The emitter's x position\r\n\t * @param emitPosY The emitter's y position\r\n\t * @param i The particle number in the current wave. Not used for this function.\r\n\t */\r\n\tprotected _spawnRect(p: Particle, emitPosX: number, emitPosY: number): void;\r\n\t/**\r\n\t * Positions a particle for a circle type emitter.\r\n\t * @param p The particle to position and rotate.\r\n\t * @param emitPosX The emitter's x position\r\n\t * @param emitPosY The emitter's y position\r\n\t * @param i The particle number in the current wave. Not used for this function.\r\n\t */\r\n\tprotected _spawnCircle(p: Particle, emitPosX: number, emitPosY: number): void;\r\n\t/**\r\n\t * Positions a particle for a ring type emitter.\r\n\t * @param p The particle to position and rotate.\r\n\t * @param emitPosX The emitter's x position\r\n\t * @param emitPosY The emitter's y position\r\n\t * @param i The particle number in the current wave. Not used for this function.\r\n\t */\r\n\tprotected _spawnRing(p: Particle, emitPosX: number, emitPosY: number): void;\r\n\t/**\r\n\t * Positions a particle for polygonal chain.\r\n\t * @param p The particle to position and rotate.\r\n\t * @param emitPosX The emitter's x position\r\n\t * @param emitPosY The emitter's y position\r\n\t * @param i The particle number in the current wave. Not used for this function.\r\n\t */\r\n\tprotected _spawnPolygonalChain(p: Particle, emitPosX: number, emitPosY: number): void;\r\n\t/**\r\n\t * Positions a particle for a burst type emitter.\r\n\t * @param p The particle to position and rotate.\r\n\t * @param emitPosX The emitter's x position\r\n\t * @param emitPosY The emitter's y position\r\n\t * @param i The particle number in the current wave.\r\n\t */\r\n\tprotected _spawnBurst(p: Particle, emitPosX: number, emitPosY: number, i: number): void;\r\n\t/**\r\n\t * Kills all active particles immediately.\r\n\t */\r\n\tcleanup(): void;\r\n\t/**\r\n\t * Destroys the emitter and all of its particles.\r\n\t */\r\n\tdestroy(): void;\r\n}\n/**\r\n * Singly linked list container for keeping track of interpolated properties for particles.\r\n * Each Particle will have one of these for each interpolated property.\r\n */\nexport declare class PropertyList<V> {\r\n\t/**\r\n\t * The current property node in the linked list.\r\n\t */\r\n\tcurrent: PropertyNode<V>;\r\n\t/**\r\n\t * The next property node in the linked list. Stored separately for slightly less variable\r\n\t * access.\r\n\t */\r\n\tnext: PropertyNode<V>;\r\n\t/**\r\n\t * Calculates the correct value for the current interpolation value. This method is set in\r\n\t * the reset() method.\r\n\t * @param lerp The interpolation value from 0-1.\r\n\t * @return The interpolated value. Colors are converted to the hex value.\r\n\t */\r\n\tinterpolate: (lerp: number) => number;\r\n\t/**\r\n\t * A custom easing method for this list.\r\n\t * @param lerp The interpolation value from 0-1.\r\n\t * @return The eased value, also from 0-1.\r\n\t */\r\n\tease: SimpleEase;\r\n\t/**\r\n\t * If this list manages colors, which requires a different method for interpolation.\r\n\t */\r\n\tprivate isColor;\r\n\t/**\r\n\t * @param isColor If this list handles color values\r\n\t */\r\n\tconstructor(isColor?: boolean);\r\n\t/**\r\n\t * Resets the list for use.\r\n\t * @param first The first node in the list.\r\n\t * @param first.isStepped If the values should be stepped instead of interpolated linearly.\r\n\t */\r\n\treset(first: PropertyNode<V>): void;\r\n}\n/** Interface for a child of a LinkedListContainer (has the prev/next properties added) */\nexport interface LinkedListChild extends DisplayObject {\r\n\tnextChild: LinkedListChild | null;\r\n\tprevChild: LinkedListChild | null;\r\n}\n/**\r\n * A semi-experimental Container that uses a doubly linked list to manage children instead of an\r\n * array. This means that adding/removing children often is not the same performance hit that\r\n * it would to be continually pushing/splicing.\r\n * However, this is primarily intended to be used for heavy particle usage, and may not handle\r\n * edge cases well if used as a complete Container replacement.\r\n */\nexport declare class LinkedListContainer extends Container {\r\n\tprivate _firstChild;\r\n\tprivate _lastChild;\r\n\tprivate _childCount;\r\n\treadonly firstChild: LinkedListChild;\r\n\treadonly lastChild: LinkedListChild;\r\n\treadonly childCount: number;\r\n\taddChild<T extends DisplayObject[]>(...children: T): T[0];\r\n\taddChildAt<T extends DisplayObject>(child: T, index: number): T;\r\n\t/**\r\n\t * Adds a child to the container to be rendered below another child.\r\n\t *\r\n\t * @param child The child to add\r\n\t * @param relative - The current child to add the new child relative to.\r\n\t * @return The child that was added.\r\n\t */\r\n\taddChildBelow<T extends DisplayObject>(child: T, relative: DisplayObject): T;\r\n\t/**\r\n\t * Adds a child to the container to be rendered above another child.\r\n\t *\r\n\t * @param child The child to add\r\n\t * @param relative - The current child to add the new child relative to.\r\n\t * @return The child that was added.\r\n\t */\r\n\taddChildAbove<T extends DisplayObject>(child: T, relative: DisplayObject): T;\r\n\tswapChildren(child: DisplayObject, child2: DisplayObject): void;\r\n\tgetChildIndex(child: DisplayObject): number;\r\n\tsetChildIndex(child: DisplayObject, index: number): void;\r\n\tremoveChild<T extends DisplayObject[]>(...children: T): T[0];\r\n\tgetChildAt(index: number): DisplayObject;\r\n\tremoveChildAt(index: number): DisplayObject;\r\n\tremoveChildren(beginIndex?: number, endIndex?: number): DisplayObject[];\r\n\t/**\r\n\t * Updates the transform on all children of this container for rendering.\r\n\t * Copied from and overrides PixiJS v5 method (v4 method is identical)\r\n\t */\r\n\tupdateTransform(): void;\r\n\t/**\r\n\t * Recalculates the bounds of the container.\r\n\t * Copied from and overrides PixiJS v5 method (v4 method is identical)\r\n\t */\r\n\tcalculateBounds(): void;\r\n\t/**\r\n\t * Retrieves the local bounds of the displayObject as a rectangle object. Copied from and overrides PixiJS v5 method\r\n\t */\r\n\tgetLocalBounds(rect?: Rectangle, skipChildrenUpdate?: boolean): Rectangle;\r\n\t/**\r\n\t * Renders the object using the WebGL renderer. Copied from and overrides PixiJS v5 method\r\n\t */\r\n\trender(renderer: Renderer): void;\r\n\t/**\r\n\t * Render the object using the WebGL renderer and advanced features. Copied from and overrides PixiJS v5 method\r\n\t */\r\n\tprotected renderAdvanced(renderer: Renderer): void;\r\n\t/**\r\n\t * Renders the object using the WebGL renderer. Copied from and overrides PixiJS V4 method.\r\n\t */\r\n\trenderWebGL(renderer: any): void;\r\n\t/**\r\n\t * Render the object using the WebGL renderer and advanced features. Copied from and overrides PixiJS V4 method.\r\n\t */\r\n\tprivate renderAdvancedWebGL;\r\n\t/**\r\n\t * Renders the object using the Canvas renderer. Copied from and overrides PixiJS V4 method or Canvas mixin in V5.\r\n\t */\r\n\trenderCanvas(renderer: any): void;\r\n}\n/**\r\n * An individual particle image. You shouldn't have to deal with these.\r\n */\nexport declare class Particle extends Sprite implements LinkedListChild {\r\n\t/**\r\n\t * The emitter that controls this particle.\r\n\t */\r\n\temitter: Emitter;\r\n\t/**\r\n\t * The velocity of the particle. Speed may change, but the angle also\r\n\t * contained in velocity is constant.\r\n\t */\r\n\tvelocity: Point;\r\n\t/**\r\n\t * The maximum lifetime of this particle, in seconds.\r\n\t */\r\n\tmaxLife: number;\r\n\t/**\r\n\t * The current age of the particle, in seconds.\r\n\t */\r\n\tage: number;\r\n\t/**\r\n\t * A simple easing function to be applied to all properties that\r\n\t * are being interpolated.\r\n\t */\r\n\tease: SimpleEase;\r\n\t/**\r\n\t * Extra data that the emitter passes along for custom particles.\r\n\t */\r\n\textraData: any;\r\n\t/**\r\n\t * The alpha of the particle throughout its life.\r\n\t */\r\n\talphaList: PropertyList<number>;\r\n\t/**\r\n\t * The speed of the particle throughout its life.\r\n\t */\r\n\tspeedList: PropertyList<number>;\r\n\t/**\r\n\t * A multiplier from 0-1 applied to the speed of the particle at all times.\r\n\t */\r\n\tspeedMultiplier: number;\r\n\t/**\r\n\t * Acceleration to apply to the particle.\r\n\t */\r\n\tacceleration: Point;\r\n\t/**\r\n\t * The maximum speed allowed for accelerating particles. Negative values, values of 0 or NaN\r\n\t * will disable the maximum speed.\r\n\t */\r\n\tmaxSpeed: number;\r\n\t/**\r\n\t * Speed at which the particle rotates, in radians per second.\r\n\t */\r\n\trotationSpeed: number;\r\n\t/**\r\n\t * Acceleration of rotation (angular acceleration) to apply to the particle.\r\n\t */\r\n\trotationAcceleration: number;\r\n\t/**\r\n\t * If particle rotation is locked, preventing rotation from occurring due\r\n\t * to directional changes.\r\n\t */\r\n\tnoRotation: boolean;\r\n\t/**\r\n\t * The scale of the particle throughout its life.\r\n\t */\r\n\tscaleList: PropertyList<number>;\r\n\t/**\r\n\t * A multiplier from 0-1 applied to the scale of the particle at all times.\r\n\t */\r\n\tscaleMultiplier: number;\r\n\t/**\r\n\t * The tint of the particle throughout its life.\r\n\t */\r\n\tcolorList: PropertyList<Color>;\r\n\t/**\r\n\t * A reference to init, so that subclasses can access it without the penalty of Function.call()\r\n\t */\r\n\tprotected Particle_init: typeof Particle.prototype.init;\r\n\t/**\r\n\t * A reference to update so that subclasses can access the original without the overhead\r\n\t * of Function.call().\r\n\t * @param delta Time elapsed since the previous frame, in __seconds__.\r\n\t * @return The standard interpolation multiplier (0-1) used for all relevant particle\r\n\t *                   properties. A value of -1 means the particle died of old age instead.\r\n\t */\r\n\tprotected Particle_update: typeof Particle.prototype.update;\r\n\tprotected Particle_destroy: typeof Particle.prototype.destroy;\r\n\tprotected Sprite_destroy: typeof Sprite.prototype.destroy;\r\n\t/**\r\n\t * If alpha should be interpolated at all.\r\n\t */\r\n\tprotected _doAlpha: boolean;\r\n\t/**\r\n\t * If scale should be interpolated at all.\r\n\t */\r\n\tprotected _doScale: boolean;\r\n\t/**\r\n\t * If speed should be interpolated at all.\r\n\t */\r\n\tprotected _doSpeed: boolean;\r\n\t/**\r\n\t * If acceleration should be handled at all. _doSpeed is mutually exclusive with this,\r\n\t * and _doSpeed gets priority.\r\n\t */\r\n\tprotected _doAcceleration: boolean;\r\n\t/**\r\n\t * If color should be interpolated at all.\r\n\t */\r\n\tprotected _doColor: boolean;\r\n\t/**\r\n\t * If normal movement should be handled. Subclasses wishing to override movement\r\n\t * can set this to false in init().\r\n\t */\r\n\tprotected _doNormalMovement: boolean;\r\n\t/**\r\n\t * One divided by the max life of the particle, saved for slightly faster math.\r\n\t */\r\n\tprivate _oneOverLife;\r\n\t/**\r\n\t * Reference to the next particle in the list.\r\n\t */\r\n\tnext: Particle;\r\n\t/**\r\n\t * Reference to the previous particle in the list.\r\n\t */\r\n\tprev: Particle;\r\n\tprevChild: LinkedListChild;\r\n\tnextChild: LinkedListChild;\r\n\t/**\r\n\t * @param {PIXI.particles.Emitter} emitter The emitter that controls this particle.\r\n\t */\r\n\tconstructor(emitter: Emitter);\r\n\t/**\r\n\t * Initializes the particle for use, based on the properties that have to\r\n\t * have been set already on the particle.\r\n\t */\r\n\tinit(): void;\r\n\t/**\r\n\t * Sets the texture for the particle. This can be overridden to allow\r\n\t * for an animated particle.\r\n\t * @param art The texture to set.\r\n\t */\r\n\tapplyArt(art: any): void;\r\n\t/**\r\n\t * Updates the particle.\r\n\t * @param delta Time elapsed since the previous frame, in __seconds__.\r\n\t * @return The standard interpolation multiplier (0-1) used for all\r\n\t *         relevant particle properties. A value of -1 means the particle\r\n\t *         died of old age instead.\r\n\t */\r\n\tupdate(delta: number): number;\r\n\t/**\r\n\t * Kills the particle, removing it from the display list\r\n\t * and telling the emitter to recycle it.\r\n\t */\r\n\tkill(): void;\r\n\t/**\r\n\t * Destroys the particle, removing references and preventing future use.\r\n\t */\r\n\tdestroy(): void;\r\n\t/**\r\n\t * Checks over the art that was passed to the Emitter's init() function, to do any special\r\n\t * modifications to prepare it ahead of time.\r\n\t * @param art The array of art data. For Particle, it should be an array of\r\n\t *            Textures. Any strings in the array will be converted to\r\n\t *            Textures via Texture.from().\r\n\t * @return The art, after any needed modifications.\r\n\t */\r\n\tstatic parseArt(art: any[]): any[];\r\n\t/**\r\n\t * Parses extra emitter data to ensure it is set up for this particle class.\r\n\t * Particle does nothing to the extra data.\r\n\t * @param extraData The extra data from the particle config.\r\n\t * @return The parsed extra data.\r\n\t */\r\n\tstatic parseData(extraData: any): any;\r\n}\n/**\r\n * An particle that follows a path defined by an algebraic expression, e.g. \"sin(x)\" or\r\n * \"5x + 3\".\r\n * To use this class, the particle config must have a \"path\" string in the\r\n * \"extraData\" parameter. This string should have \"x\" in it to represent movement (from the\r\n * speed settings of the particle). It may have numbers, parentheses, the four basic\r\n * operations, and the following Math functions or properties (without the preceding \"Math.\"):\r\n * \"pow\", \"sqrt\", \"abs\", \"floor\", \"round\", \"ceil\", \"E\", \"PI\", \"sin\", \"cos\", \"tan\", \"asin\",\r\n * \"acos\", \"atan\", \"atan2\", \"log\".\r\n * The overall movement of the particle and the expression value become x and y positions for\r\n * the particle, respectively. The final position is rotated by the spawn rotation/angle of\r\n * the particle.\r\n *\r\n * Some example paths:\r\n *\r\n * \t\"sin(x/10) * 20\" // A sine wave path.\r\n * \t\"cos(x/100) * 30\" // Particles curve counterclockwise (for medium speed/low lifetime particles)\r\n * \t\"pow(x/10, 2) / 2\" // Particles curve clockwise (remember, +y is down).\r\n */\nexport declare class PathParticle extends Particle {\r\n\t/**\r\n\t * The function representing the path the particle should take.\r\n\t */\r\n\tpath: Function;\r\n\t/**\r\n\t * The initial rotation in degrees of the particle, because the direction of the path\r\n\t * is based on that.\r\n\t */\r\n\tinitialRotation: number;\r\n\t/**\r\n\t * The initial position of the particle, as all path movement is added to that.\r\n\t */\r\n\tinitialPosition: Point;\r\n\t/**\r\n\t * Total single directional movement, due to speed.\r\n\t */\r\n\tmovement: number;\r\n\t/**\r\n\t * @param {PIXI.particles.Emitter} emitter The emitter that controls this PathParticle.\r\n\t */\r\n\tconstructor(emitter: Emitter);\r\n\t/**\r\n\t * Initializes the particle for use, based on the properties that have to\r\n\t * have been set already on the particle.\r\n\t */\r\n\tinit(): void;\r\n\t/**\r\n\t * Updates the particle.\r\n\t * @param delta Time elapsed since the previous frame, in __seconds__.\r\n\t */\r\n\tupdate(delta: number): number;\r\n\t/**\r\n\t * Destroys the particle, removing references and preventing future use.\r\n\t */\r\n\tdestroy(): void;\r\n\t/**\r\n\t * Checks over the art that was passed to the Emitter's init() function, to do any special\r\n\t * modifications to prepare it ahead of time. This just runs Particle.parseArt().\r\n\t * @param art The array of art data. For Particle, it should be an array of\r\n\t *            Textures. Any strings in the array will be converted to\r\n\t *            Textures via Texture.fromImage().\r\n\t * @return The art, after any needed modifications.\r\n\t */\r\n\tstatic parseArt(art: (Texture | string)[]): Texture[];\r\n\t/**\r\n\t * Parses extra emitter data to ensure it is set up for this particle class.\r\n\t * PathParticle checks for the existence of path data, and parses the path data for use\r\n\t * by particle instances.\r\n\t * @param extraData The extra data from the particle config.\r\n\t * @return The parsed extra data.\r\n\t */\r\n\tstatic parseData(extraData: {\r\n\t\tpath: string;\r\n\t}): any;\r\n}\nexport interface ParsedAnimatedParticleArt {\r\n\ttextures: Texture[];\r\n\tduration: number;\r\n\tframerate: number;\r\n\tloop: boolean;\r\n}\nexport interface AnimatedParticleArt {\r\n\tframerate: 'matchLife' | number;\r\n\tloop?: boolean;\r\n\ttextures: (string | Texture | {\r\n\t\ttexture: string | Texture;\r\n\t\tcount: number;\r\n\t})[];\r\n}\n/**\r\n * An individual particle image with an animation. Art data passed to the emitter must be\r\n * formatted in a particular way for AnimatedParticle to be able to handle it:\r\n *\r\n * ```typescript\r\n * {\r\n *     //framerate is required. It is the animation speed of the particle in frames per\r\n *     //second.\r\n *     //A value of \"matchLife\" causes the animation to match the lifetime of an individual\r\n *     //particle, instead of at a constant framerate. This causes the animation to play\r\n *     //through one time, completing when the particle expires.\r\n *     framerate: 6,\r\n *     //loop is optional, and defaults to false.\r\n *     loop: true,\r\n *     //textures is required, and can be an array of any (non-zero) length.\r\n *     textures: [\r\n *         //each entry represents a single texture that should be used for one or more\r\n *         //frames. Any strings will be converted to Textures with Texture.from().\r\n *         //Instances of PIXI.Texture will be used directly.\r\n *         \"animFrame1.png\",\r\n *         //entries can be an object with a 'count' property, telling AnimatedParticle to\r\n *         //use that texture for 'count' frames sequentially.\r\n *         {\r\n *             texture: \"animFrame2.png\",\r\n *             count: 3\r\n *         },\r\n *         \"animFrame3.png\"\r\n *     ]\r\n * }\r\n * ```\r\n */\nexport declare class AnimatedParticle extends Particle {\r\n\t/**\r\n\t * Texture array used as each frame of animation, similarly to how MovieClip works.\r\n\t */\r\n\tprivate textures;\r\n\t/**\r\n\t * Duration of the animation, in seconds.\r\n\t */\r\n\tprivate duration;\r\n\t/**\r\n\t * Animation framerate, in frames per second.\r\n\t */\r\n\tprivate framerate;\r\n\t/**\r\n\t * Animation time elapsed, in seconds.\r\n\t */\r\n\tprivate elapsed;\r\n\t/**\r\n\t * If this particle animation should loop.\r\n\t */\r\n\tprivate loop;\r\n\t/**\r\n\t * @param emitter The emitter that controls this AnimatedParticle.\r\n\t */\r\n\tconstructor(emitter: Emitter);\r\n\t/**\r\n\t * Initializes the particle for use, based on the properties that have to\r\n\t * have been set already on the particle.\r\n\t */\r\n\tinit(): void;\r\n\t/**\r\n\t * Sets the textures for the particle.\r\n\t * @param art An array of PIXI.Texture objects for this animated particle.\r\n\t */\r\n\tapplyArt(art: ParsedAnimatedParticleArt): void;\r\n\t/**\r\n\t * Updates the particle.\r\n\t * @param delta Time elapsed since the previous frame, in __seconds__.\r\n\t */\r\n\tupdate(delta: number): number;\r\n\t/**\r\n\t * Destroys the particle, removing references and preventing future use.\r\n\t */\r\n\tdestroy(): void;\r\n\t/**\r\n\t * Checks over the art that was passed to the Emitter's init() function, to do any special\r\n\t * modifications to prepare it ahead of time.\r\n\t * @param art The array of art data, properly formatted for AnimatedParticle.\r\n\t * @return The art, after any needed modifications.\r\n\t */\r\n\tstatic parseArt(art: AnimatedParticleArt[]): any;\r\n}\n\nexport {};\n"
    ]
  