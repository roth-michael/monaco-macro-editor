
    export default [
      "@league-of-foundry-developers/foundry-vtt-types/src/foundry/common/utils/helpers.mjs.d.ts",
      "/**\n * Benchmark the performance of a function, calling it a requested number of iterations.\n * @param func       - The function to benchmark\n * @param iterations - The number of iterations to test\n */\nexport declare function benchmark(func: () => unknown, iterations: number): void;\n\n/**\n * Wrap a callback in a debounced timeout.\n * Delay execution of the callback function until the function has not been called for delay milliseconds\n * @param callback - A function to execute once the debounced threshold has been passed\n * @param delay    - An amount of time in milliseconds to delay\n * @returns A wrapped function which can be called to debounce execution\n */\nexport declare function debounce<T extends (...args: any[]) => unknown>(\n  callback: T,\n  delay: number\n): (...args: Parameters<T>) => void;\n\n/**\n * Quickly clone a simple piece of data, returning a copy which can be mutated safely.\n * This method DOES support recursive data structures containing inner objects or arrays.\n * This method DOES NOT support advanced object types like Set, Map, or other specialized classes.\n * @param original - Some sort of data\n * @returns The clone of that data\n */\nexport declare function deepClone<T>(original: T): T;\n\n/**\n * Deeply difference an object against some other, returning the update keys and values\n * @param original - An object comparing data against which to compare.\n * @param other    - An object containing potentially different data.\n * @param options  - Additional options which configure the diff operation\n * @returns An object of the data in other which differs from that in original.\n */\nexport declare function diffObject(original: object, other: object, { inner }?: DiffObjectOptions): object;\n\ninterface DiffObjectOptions {\n  /**\n   * Only recognize differences in other for keys which also exist in original\n   * @defaultValue `false`\n   */\n  inner?: boolean;\n}\n\n/**\n * A cheap data duplication trick which is relatively robust.\n * For a subset of cases the deepClone function will offer better performance.\n * @param original - Some sort of data\n * @typeParam T    - Type of the original data.\n *\n * @remarks This function will actually convert any occurrences of `NaN` and `Infinity` to `null`. For ease of use, this\n * is _not_ reflected in the type. Be careful if your types might contain `NaN` or `Infinity`!\n */\nexport declare function duplicate<T>(original: T): Duplicated<T>;\n\n/**\n * Internal Helper for {@link Duplicated}. A union type of all primitive types that do not have a JSON representation.\n *\n * @internal\n */\ntype NonStringifiable = undefined | Function | symbol;\n\n/**\n * Internal helper for {@link InnerDuplicated}. Maps the properties of `T` to their duplicated types.\n *\n * @typeParam T - The object type that should have its properties mapped.\n * @internal\n */\ntype MapToInnerDuplicated<T extends object> = { [k in keyof T]: InnerDuplicated<T[k]> };\n\n/**\n * Internal helper type for {@link Duplicated}. It is the main part of the implementation, which does the recursion.\n *\n * @typeParam T - Type currently being converted.\n * @internal\n */\n// prettier-ignore\ntype InnerDuplicated<T> = T extends { toJSON(): infer U }\n   ? U extends Array<unknown>\n     ? InnerDuplicated<U>\n     : U extends object\n       ? InnerDuplicated<Omit<U, 'toJSON'>>\n       : InnerDuplicated<U>\n   : T extends NonStringifiable\n     ? undefined\n     : T extends Array<unknown>\n       ? MapToInnerDuplicated<MapTypeToType<T, NonStringifiable, null>>\n       : T extends object\n         ? MapToInnerDuplicated<\n           OmitAssignableFromType<MapTypeToType<T, NonStringifiable, undefined>, undefined> &\n             Partial<OmitOfType<OmitNotAssignableFromType<MapTypeToType<T, NonStringifiable, undefined>, undefined>, undefined>>\n           >\n         : T;\n\n/**\n * The resulting type when using {@link duplicate} on some data of type `T`.\n *\n * @typeParam T - Original type.\n * @internal\n */\nexport type Duplicated<T> = T extends NonStringifiable ? never : InnerDuplicated<T>;\n\n/**\n * Encode a url-like string by replacing any characters which need encoding\n * @param path - A fully-qualified URL or url component (like a relative path)\n * @returns An encoded URL string\n */\nexport declare function encodeURL(path: string): string;\n\n/**\n * Expand a flattened object to be a standard multi-dimensional nested Object by converting all dot-notation keys to\n * inner objects.\n *\n * @param obj - The object to expand\n * @param _d  - Track the recursion depth to prevent overflow\n *              (default: `0`)\n * @returns An expanded object\n */\nexport declare function expandObject(obj: object, _d?: number): any;\n\n/**\n * Filter the contents of some source object using the structure of a template object.\n * Only keys which exist in the template are preserved in the source object.\n *\n * @param source   - An object which contains the data you wish to filter\n * @param template - An object which contains the structure you wish to preserve\n * @param options  - Additional options which customize the filtration\n *                   (default: `{}`)\n *\n * @example\n * ```typescript\n * const source = {foo: {number: 1, name: \"Tim\", topping: \"olives\"}, bar: \"baz\"};\n * const template = {foo: {number: 0, name: \"Mit\", style: \"bold\"}, other: 72};\n * filterObject(source, template); // {foo: {number: 1, name: \"Tim\"}};\n * filterObject(source, template, {templateValues: true}); // {foo: {number: 0, name: \"Mit\"}};\n * ```\n */\nexport declare function filterObject(source: object, template: object, options?: FilterObjectOptions): any;\n\ninterface FilterObjectOptions {\n  /**\n   * Whether to keep special tokens like deletion keys\n   * @defaultValue `false`\n   */\n  keepSpecial?: boolean;\n\n  /**\n   * Instead of keeping values from the source, instead draw values from the template\n   * @defaultValue `false`\n   */\n  templateValues?: boolean;\n}\n\n/**\n * Flatten a possibly multi-dimensional object to a one-dimensional one by converting all nested keys to dot notation\n * @param obj - The object to flatten\n * @param d   - Track the recursion depth to prevent overflow\n * @returns A flattened object\n */\nexport declare function flattenObject(obj: object, _d?: number): any;\n\n/**\n * Obtain references to the parent classes of a certain class.\n * @param cls - An ES6 Class definition\n * @returns An array of parent Classes which the provided class extends\n */\nexport declare function getParentClasses(cls: ConstructorOf<any>): Array<ConstructorOf<any>>;\n\n/**\n * A helper function which searches through an object to retrieve a value by a string key.\n * The string key supports the notation a.b.c which would return object[a][b][c]\n * @param object - The object to traverse\n * @param key    - An object property with notation a.b.c\n * @returns The value of the found property\n */\nexport declare function getProperty(object: object, key: string): any;\n\n/**\n * Get the URL route for a certain path which includes a path prefix, if one is set\n * @param path   - The Foundry URL path\n * @param prefix - A path prefix to apply\n *                 (default: `null`)\n * @returns The absolute URL path\n */\nexport declare function getRoute(\n  path: string,\n  {\n    prefix\n  }?: {\n    prefix?: string | null;\n  }\n): string;\n\n/**\n * Learn the named type of a token - extending the functionality of typeof to recognize some core Object types\n * @param token - Some passed token\n * @returns The named type of the token\n */\nexport declare function getType(token: unknown): string;\n\n/**\n * A helper function which tests whether an object has a property or nested property given a string key.\n * The string key supports the notation a.b.c which would return true if object[a][b][c] exists\n * @param object - The object to traverse\n * @param key    - An object property with notation a.b.c\n * @returns An indicator for whether the property exists\n */\nexport declare function hasProperty(object: object, key: string): boolean;\n\n/**\n * Invert an object by assigning its values as keys and its keys as values.\n * @param obj - The original object to invert\n * @returns The inverted object with keys and values swapped\n */\nexport declare function invertObject<T extends Record<string | number | symbol, string | number | symbol>>(\n  obj: T\n): { [Key in keyof T as T[Key]]: Key };\n\n/**\n * Return whether or not a target version (v1) is more advanced than some other reference version (v0).\n * Supports either numeric or string version comparison with version parts separated by periods.\n * @param v1 - The target version\n * @param v0 - The reference version\n * @returns Is v1 a more advanced version than v0?\n */\nexport declare function isNewerVersion(v1: number | string, v0: number | string): boolean;\n\n/**\n * A simple function to test whether or not an Object is empty\n * @param obj - The object to test\n * @returns Is the object empty?\n */\nexport declare function isObjectEmpty(obj: object): boolean;\n\n/**\n * Update a source object by replacing its keys and values with those from a target object.\n *\n * @param original - The initial object which should be updated with values from the target\n * @param other    - A new object whose values should replace those in the source\n *                   (default: `{}`)\n * @param options  - Additional options which configure the merge\n *                   (default: `{}`)\n * @param _d       - A privately used parameter to track recursion depth.\n *                   (default: `0`)\n * @returns The original source object including updated, inserted, or overwritten records.\n *\n * @example <caption>Control how new keys and values are added</caption>\n * ```typescript\n * mergeObject({k1: \"v1\"}, {k2: \"v2\"}, {insertKeys: false}); // {k1: \"v1\"}\n * mergeObject({k1: \"v1\"}, {k2: \"v2\"}, {insertKeys: true});  // {k1: \"v1\", k2: \"v2\"}\n * mergeObject({k1: {i1: \"v1\"}}, {k1: {i2: \"v2\"}}, {insertValues: false}); // {k1: {i1: \"v1\"}}\n * mergeObject({k1: {i1: \"v1\"}}, {k1: {i2: \"v2\"}}, {insertValues: true}); // {k1: {i1: \"v1\", i2: \"v2\"}}\n * ```\n *\n * @example <caption>Control how existing data is overwritten</caption>\n * ```typescript\n * mergeObject({k1: \"v1\"}, {k1: \"v2\"}, {overwrite: true}); // {k1: \"v2\"}\n * mergeObject({k1: \"v1\"}, {k1: \"v2\"}, {overwrite: false}); // {k1: \"v1\"}\n * ```\n *\n * @example <caption>Control whether merges are performed recursively</caption>\n * ```typescript\n * mergeObject({k1: {i1: \"v1\"}}, {k1: {i2: \"v2\"}}, {recursive: false}); // {k1: {i1: \"v2\"}}\n * mergeObject({k1: {i1: \"v1\"}}, {k1: {i2: \"v2\"}}, {recursive: true}); // {k1: {i1: \"v1\", i2: \"v2\"}}\n * ```\n *\n * @example <caption>Deleting an existing object key</caption>\n * ```typescript\n * mergeObject({k1: \"v1\", k2: \"v2\"}, {\"-=k1\": null});   // {k2: \"v2\"}\n * ```\n */\ntype OmitByValue<T, ValueType> = { [Key in keyof T as T[Key] extends ValueType ? never : Key]: T[Key] };\ntype RemoveNever<T> = OmitByValue<T, never>;\ntype PropWithMinus<K> = K extends string ? `-=${K}` : never;\ntype DeleteByObjectKeys<T, U> = RemoveNever<{\n  [K in keyof T]: PropWithMinus<K> extends keyof U ? (U[PropWithMinus<K>] extends null ? never : T[K]) : T[K];\n}>;\ntype RemoveDeletingObjectKeys<T> = RemoveNever<{\n  [K in keyof T]: K extends string ? (Capitalize<K> extends K ? (T[K] extends null ? never : T[K]) : T[K]) : T[K];\n}>;\n\ntype MergeObjectProperty<T, U, M extends MergeObjectOptions> = T extends Array<any>\n  ? U\n  : T extends Record<string, any>\n  ? U extends Record<string, any>\n    ? M extends { recursive: false }\n      ? U\n      : Result<T, U, Omit<M, 'insertKeys'> & { insertKeys: M['insertValues'] }>\n    : U\n  : U;\ntype UpdateKeys<T, U, M extends MergeObjectOptions> = M extends { overwrite: false }\n  ? T\n  : { [K in keyof T]: K extends keyof U ? MergeObjectProperty<T[K], U[K], M> : T[K] };\ntype InsertKeys<T, U> = T & Omit<U, keyof T>;\ntype UpdateInsert<T, U, M extends MergeObjectOptions> = M extends { insertKeys: false }\n  ? UpdateKeys<T, U, M>\n  : InsertKeys<UpdateKeys<T, U, M>, U>;\ntype Result<T, U, M extends MergeObjectOptions> = UpdateInsert<\n  DeleteByObjectKeys<T, U>,\n  RemoveDeletingObjectKeys<U>,\n  M\n>;\n\ntype WithWidenedArrayTypes<T> = T extends Array<any>\n  ? Array<any>\n  : T extends Record<string, any>\n  ? { [K in keyof T]: WithWidenedArrayTypes<T[K]> }\n  : T;\n\nexport declare function mergeObject<\n  T extends object,\n  U extends DeepPartial<WithWidenedArrayTypes<T>>,\n  M extends MergeObjectOptions & { enforceTypes: true }\n>(original: T, other?: U, options?: M, _d?: number): Result<T, U, M>;\nexport declare function mergeObject<\n  T extends object,\n  U extends DeepPartial<Record<keyof T, never>> & object,\n  M extends MergeObjectOptions & { enforceTypes: true }\n>(original: T, other?: U, options?: M, _d?: number): Result<T, U, M>;\nexport declare function mergeObject<\n  T extends object,\n  U extends object,\n  M extends MergeObjectOptions & { enforceTypes: true }\n>(original: T, other?: U, options?: M, _d?: number): never;\nexport declare function mergeObject<T extends object, U extends object, M extends MergeObjectOptions>(\n  original: T,\n  other?: U,\n  options?: M,\n  _d?: number\n): Result<T, U, M>;\n\ninterface MergeObjectOptions {\n  /**\n   * Control whether to insert new top-level objects into the resulting structure which do not previously exist in the original object.\n   * @defaultValue `true`\n   */\n  insertKeys?: boolean | undefined;\n\n  /**\n   * Control whether to insert new nested values into child objects in the resulting structure which did not previously exist in the original object.\n   * @defaultValue `true`\n   */\n  insertValues?: boolean | undefined;\n\n  /**\n   * Control whether to replace existing values in the source, or only merge values which do not already exist in the original object.\n   * @defaultValue `true`\n   */\n  overwrite?: boolean | undefined;\n\n  /**\n   * Control whether to merge inner-objects recursively (if true), or whether to simply replace inner objects with a provided new value.\n   * @defaultValue `true`\n   */\n  recursive?: boolean | undefined;\n\n  /**\n   * Control whether to apply updates to the original object in-place (if true), otherwise the original object is duplicated and the copy is merged.\n   * @defaultValue `true`\n   */\n  inplace?: boolean | undefined;\n\n  /**\n   * Control whether strict type checking requires that the value of a key in the other object must match the data type in the original data to be merged.\n   * @defaultValue `false`\n   */\n  enforceTypes?: boolean | undefined;\n}\n\n/**\n * A helper function for merging objects when the target key does not exist in the original\n */\ndeclare function _mergeInsert(\n  original: object,\n  k: string,\n  v: unknown,\n  { insertKeys, insertValues }: { insertKeys?: boolean; insertValues?: boolean },\n  _d: number\n): void;\n\n/**\n * A helper function for merging objects when the target key exists in the original\n */\ndeclare function _mergeUpdate(\n  original: object,\n  k: string,\n  v: unknown,\n  {\n    insertKeys,\n    insertValues,\n    enforceTypes,\n    overwrite,\n    recursive\n  }: { insertKeys?: boolean; insertValues?: boolean; enforceTypes?: boolean; overwrite?: boolean; recursive?: boolean },\n  _d: number\n): void;\n\n/**\n * Generate a random string ID of a given requested length.\n * @param length - The length of the random ID to generate\n *                 (default: `16`)\n * @returns Return a string containing random letters and numbers\n */\nexport declare function randomID(length?: number): string;\n\n/**\n * A helper function which searches through an object to assign a value using a string key\n * This string key supports the notation a.b.c which would target object[a][b][c]\n * @param object - The object to update\n * @param key    - The string key\n * @param value  - The value to be assigned\n * @returns Whether the value was changed from its previous value\n */\nexport declare function setProperty(object: object, key: string, value: any): boolean;\n\n/**\n * Express a timestamp as a relative string\n * TODO - figure out a way to localize this\n * @param timeStamp - A timestamp string or Date object to be formatted as a relative time\n * @returns A string expression for the relative time\n */\nexport declare function timeSince(timeStamp: Date | string): string;\n\n/**\n * Converts an RGB color value to HSV. Conversion formula adapted from http://en.wikipedia.org/wiki/HSV_color_space.\n * Assumes r, g, and b are contained in the set [0, 1] and returns h, s, and v in the set [0, 1].\n * @param r - The red color value\n * @param g - The green color value\n * @param b - The blue color value\n * @returns The HSV representation\n */\nexport declare function rgbToHsv(r: number, g: number, b: number): [h: number, s: number, v: number];\n\n/**\n * Converts an HSV color value to RGB. Conversion formula adapted from http://en.wikipedia.org/wiki/HSV_color_space.\n * Assumes h, s, and v are contained in the set [0, 1] and returns r, g, and b in the set [0, 1].\n * @param h - The hue\n * @param s - The saturation\n * @param v - The value\n * @returns The RGB representation\n */\nexport declare function hsvToRgb(h: number, s: number, v: number): [r: number, g: number, b: number];\n\n/**\n * Converts a color as an [R, G, B] array of normalized floats to a hexadecimal number.\n * @param rgb - Array of numbers where all values are normalized floats from 0.0 to 1.0.\n * @returns The numeric color as hexadecimal\n */\nexport declare function rgbToHex(rgb: [r: number, g: number, b: number]): number;\n\n/**\n * Convert a hex color code to an RGB array\n * @param hex - A hex color number\n * @returns An array of [r,g,b] colors normalized on the range of [0,1]\n */\nexport declare function hexToRGB(hex: number): [r: number, g: number, b: number];\n\n/**\n * Convert a hex color code to an RGBA color string which can be used for CSS styling\n * @param hex   - A hex color number\n * @param alpha - An optional level of transparency\n *                (default: `1.0`)\n * @returns An rgba style string\n */\nexport declare function hexToRGBAString(hex: number, alpha?: number): `rgba(${number}, ${number}, ${number})`;\n\n/**\n * Convert a string color to a hex integer\n * @param color - The string color\n * @returns The hexadecimal color code\n */\nexport declare function colorStringToHex(color: string): number | null;\n"
    ]
  