
    export default [
      "@league-of-foundry-developers/foundry-vtt-types/src/foundry/foundry.js/pixi/containers/canvasLayers/placeablesLayers/wallsLayer.d.ts",
      "import { ConfiguredDocumentClass, ConfiguredObjectClassForName } from '../../../../../../types/helperTypes';\nimport { PasteOptions } from '../placeablesLayer';\n\ndeclare global {\n  /**\n   * The Walls canvas layer which provides a container for Wall objects within the rendered Scene.\n   * @see {@link WallDocument}\n   * @see {@link Wall}\n   */\n  class WallsLayer extends PlaceablesLayer<'Wall', WallsLayer.LayerOptions> {\n    constructor();\n\n    /**\n     * A graphics layer used to display chained Wall selection\n     * @defaultValue `null`\n     */\n    chain: PIXI.Graphics | null;\n\n    /**\n     * An array of all the unique perception-blocking endpoints which are present in the layer\n     * We keep this array cached for faster sight polygon computations\n     * @defaultValue `[]`\n     */\n    endpoints: PointArray[];\n\n    /**\n     * Track whether we are currently within a chained placement workflow\n     * @defaultValue `false`\n     */\n    protected _chain: boolean;\n\n    /**\n     * Track whether the layer is currently toggled to snap at exact grid precision\n     * @defaultValue `false`\n     */\n    protected _forceSnap: boolean;\n\n    /**\n     * Track the most recently created or updated wall data for use with the clone tool\n     * @defaultValue `null`\n     * @remarks This is intentional `public` because it is accessed from Wall\n     */\n    _cloneType: ReturnType<foundry.documents.BaseWall['toJSON']> | null;\n\n    /**\n     * Reference the last interacted wall endpoint for the purposes of chaining\n     * @defaultValue\n     * ```\n     * {\n     *   id: null,\n     *   point: null,\n     * }\n     * ```\n     */\n    protected last: {\n      id: string | null;\n      point: PointArray | null;\n    };\n\n    /**\n     * @remarks This is not overridden in foundry but reflects the real behavior.\n     */\n    static get instance(): Canvas['walls'];\n\n    /**\n     * @override\n     * @defaultValue\n     * ```\n     * mergeObject(super.layerOptions, {\n     *  name: \"walls\"\n     *  controllableObjects: true,\n     *  objectClass: Wall,\n     *  quadtree: true,\n     *  sheetClass: WallConfig,\n     *  sortActiveTop: true,\n     *  zIndex: 40\n     * })\n     * ```\n     */\n    static get layerOptions(): WallsLayer.LayerOptions;\n\n    /** @override */\n    static documentName: 'Wall';\n\n    /**\n     * An Array of Wall instances in the current Scene which act as Doors.\n     */\n    get doors(): InstanceType<ConfiguredObjectClassForName<'Wall'>>[];\n\n    /**\n     * Gate the precision of wall snapping to become less precise for small scale maps.\n     * @remarks Returns `1 | 4 | 8 | 16`\n     */\n    get gridPrecision(): number;\n\n    /**\n     * @override\n     */\n    draw(): Promise<this>;\n\n    /** @override */\n    deactivate(): this;\n\n    /**\n     * Perform initialization steps for the WallsLayer whenever the composition of walls in the Scene is changed.\n     * Cache unique wall endpoints and identify interior walls using overhead roof tiles.\n     */\n    initialize(): void;\n\n    /**\n     * Identify walls which are treated as \"interior\" because they are contained fully within a roof tile.\n     */\n    identifyInteriorWalls(): void;\n\n    /**\n     * Given a point and the coordinates of a wall, determine which endpoint is closer to the point\n     * @param point - The origin point of the new Wall placement\n     * @param wall  - The existing Wall object being chained to\n     * @returns The [x,y] coordinates of the starting endpoint\n     */\n    static getClosestEndpoint(point: Point, wall: InstanceType<ConfiguredObjectClassForName<'Wall'>>): PointArray;\n\n    /**\n     * Given an array of Wall instances, identify the unique endpoints across all walls.\n     * @param walls   - An array of Wall instances\n     * @param options - Additional options which modify the set of endpoints identified\n     *                  (defaultValue: `{}`)\n     * @returns An array of endpoints\n     */\n    static getUniqueEndpoints(\n      walls:\n        | InstanceType<ConfiguredObjectClassForName<'Wall'>>[]\n        | Set<InstanceType<ConfiguredObjectClassForName<'Wall'>>>,\n      options?: EndpointOptions\n    ): PointArray[];\n\n    /**\n     * Test whether movement along a given Ray collides with a Wall.\n     * @param ray     - The attempted movement\n     * @param options - Options which customize how collision is tested\n     * @returns Does a collision occur?\n     */\n    checkCollision(ray: Ray, options: CollisionOptions & { mode: 'all' }): boolean | RayIntersection[];\n    checkCollision(ray: Ray, options: CollisionOptions & { mode: 'closest' }): boolean | RayIntersection | null;\n    checkCollision(ray: Ray, options: CollisionOptions & { mode: 'any' }): boolean;\n    checkCollision(ray: Ray, options: Omit<CollisionOptions, 'mode'>): boolean;\n    checkCollision(ray: Ray, options: CollisionOptions): boolean | RayIntersection | null;\n    checkCollision(ray: Ray, options?: CollisionOptions): boolean;\n\n    /**\n     * Highlight the endpoints of Wall segments which are currently group-controlled on the Walls layer\n     */\n    highlightControlledSegments(): void;\n\n    /** @override */\n    releaseAll(options?: PlaceableObject.ReleaseOptions): number;\n\n    /**\n     * @override\n     * @param options - (unused)\n     */\n    pasteObjects(\n      position: Point,\n      options?: PasteOptions\n    ): Promise<InstanceType<ConfiguredDocumentClass<typeof foundry.documents.BaseWall>>[]>;\n\n    /**\n     * Pan the canvas view when the cursor position gets close to the edge of the frame\n     * @param event - The originating mouse movement event\n     * @param x     - The x-coordinate\n     * @param y     - The y-coordinate\n     */\n    protected _panCanvasEdge(event: MouseEvent, x: number, y: number): void | ReturnType<Canvas['animatePan']>;\n\n    /**\n     * Get the endpoint coordinates for a wall placement, snapping to grid at a specified precision\n     * Require snap-to-grid until a redesign of the wall chaining system can occur.\n     * @param  point - The initial candidate point\n     * @param  snap  - Whether to snap to grid\n     *                 (default: `true`)\n     * @returns The endpoint coordinates [x,y]\n     */\n    protected _getWallEndpointCoordinates(point: Point, { snap }?: { snap?: boolean }): PointArray;\n\n    /**\n     * The Scene Controls tools provide several different types of prototypical Walls to choose from\n     * This method helps to translate each tool into a default wall data configuration for that type\n     * @param tool - The active canvas tool\n     */\n    protected _getWallDataFromActiveTool(tool: string):\n      | {\n          move: foundry.CONST.WallMovementType;\n          sense: foundry.CONST.WallSenseType;\n          door?: foundry.CONST.WallDoorType;\n        }\n      | this['_cloneType'];\n\n    /** @override */\n    protected _onDragLeftStart(event: PIXI.InteractionEvent): Promise<Wall>;\n\n    /** @override */\n    protected _onDragLeftMove(event: PIXI.InteractionEvent): void;\n\n    /** @override */\n    protected _onDragLeftDrop(event: PIXI.InteractionEvent): void;\n\n    /** @override */\n    protected _onDragLeftCancel(event: PointerEvent): void;\n\n    /** @override */\n    protected _onClickRight(event: PIXI.InteractionEvent): void;\n\n    /**\n     * Compute source polygons of a requested type for a given origin position and maximum radius.\n     * This method returns two polygons, one which is unrestricted by the provided radius, and one that is constrained\n     * by the maximum radius.\n     *\n     * @param origin  - An point with coordinates x and y representing the origin of the test\n     * @param radius  - A distance in canvas pixels which reflects the visible range\n     * @param options - Additional options which modify the sight computation\n     *                  (default: `{}`)\n     * @returns The computed rays and polygons\n     */\n    computePolygon(\n      origin: Point,\n      radius: number,\n      options?: ComputePolygonOptions\n    ): { rays: Ray[]; los: PIXI.Polygon; fov: PIXI.Polygon };\n\n    /**\n     * Get the set of wall collisions for a given Ray\n     * @param ray     - The Ray being tested\n     * @param options - Options which customize how collision is tested\n     *                  (default: `{}`)\n     * @returns An array of collisions, if mode is \"all\"\n     *          The closest collision, if mode is \"closest\"\n     *          Whether any collision occurred if mode is \"any\"\n     */\n    getRayCollisions(ray: Ray, options: RayCollisionsOptions & { mode: 'all' }): RayIntersection[];\n    getRayCollisions(ray: Ray, options: RayCollisionsOptions & { mode: 'closest' }): RayIntersection | null;\n    getRayCollisions(ray: Ray, options: RayCollisionsOptions & { mode: 'any' }): boolean;\n    getRayCollisions(ray: Ray, options?: Partial<Omit<RayCollisionsOptions, 'mode'>>): RayIntersection[];\n    getRayCollisions(ray: Ray, options?: RayCollisionsOptions): RayIntersection[] | RayIntersection | boolean | null;\n\n    /**\n     * A helper method responsible for casting rays at wall endpoints.\n     * Rays are restricted by limiting angles.\n     *\n     * @param x          - The origin x-coordinate\n     * @param y          - The origin y-coordinate\n     * @param distance   - The ray distance\n     * @param density    - The desired radial density\n     *                     (default: `4`)\n     * @param endpoints  - An array of endpoints to target\n     * @param limitAngle - Whether the rays should be cast subject to a limited angle of emission\n     *                     (default: `false`)\n     * @param aMin       - The minimum bounding angle\n     * @param aMax       - The maximum bounding angle\n     *\n     * @returns An array of Ray objects\n     */\n    static castRays(\n      x: number,\n      y: number,\n      distance: number,\n      {\n        density,\n        endpoints,\n        limitAngle,\n        aMin,\n        aMax\n      }?: { density?: number; endpoints?: PointArray[]; limitAngle?: boolean; aMin?: number; aMax?: number }\n    ): Ray[];\n\n    /**\n     * Test a single Ray against a single Wall\n     * @param ray  - The Ray being tested\n     * @param wall - The Wall against which to test\n     * @returns A RayIntersection if a collision occurred, or null\n     */\n    static testWall(ray: Ray, wall: InstanceType<ConfiguredObjectClassForName<'Wall'>>): RayIntersection | null;\n\n    /**\n     * Identify the closest collision point from an array of collisions\n     * @param collisions - An array of intersection points\n     * @returns The closest blocking intersection or null if no collision occurred\n     */\n    static getClosestCollision(collisions: RayIntersection[]): RayIntersection | null;\n\n    /**\n     * Normalize an angle to ensure it is baselined to be the smallest angle that is greater than a minimum.\n     * @param aMin  - The lower-bound minimum angle\n     * @param angle - The angle to adjust\n     * @returns The adjusted angle which is greater than or equal to aMin.\n     */\n    protected static _normalizeAngle(aMin: number, angle: number): number;\n\n    /**\n     * Map source types to wall collision types\n     * @param type - The source polygon type\n     * @returns The wall collision attribute\n     */\n    protected static _mapCollisionType(type: 'movement'): 'move';\n    protected static _mapCollisionType(type: 'light'): 'sense';\n    protected static _mapCollisionType(type: 'sight'): 'sense';\n    protected static _mapCollisionType(type: 'sound'): 'sound';\n\n    /**\n     * @deprecated since 0.8.0\n     */\n    get blockVision(): InstanceType<ConfiguredObjectClassForName<'Wall'>>[];\n\n    /**\n     * @deprecated since 0.8.0\n     */\n    get blockMovement(): InstanceType<ConfiguredObjectClassForName<'Wall'>>[];\n  }\n\n  namespace WallsLayer {\n    interface LayerOptions extends PlaceablesLayer.LayerOptions<'Wall'> {\n      name: 'walls';\n      controllableObjects: true;\n      objectClass: typeof Wall;\n      quadtree: true;\n      sheetClass: ConstructorOf<FormApplication>;\n      sortActiveTop: boolean;\n      zIndex: number;\n    }\n  }\n}\n\ninterface EndpointOptions {\n  /**\n   * An optional bounding rectangle within which the endpoint must lie.\n   */\n  bounds?: NormalizedRectangle;\n\n  /**\n   * The type of polygon being computed: \"movement\", \"sight\", or \"sound\"\n   * @defaultValue `'movement'`\n   */\n  type?: 'movement' | 'sight' | 'sound';\n}\n\ninterface CollisionOptions {\n  /**\n   * Which collision type to check: movement, sight, sound\n   * @defaultValue `'movement'`\n   */\n  type?: 'movement' | 'sight' | 'sound';\n\n  /**\n   * Which type of collisions are returned: any, closest, all\n   * @defaultValue `'any'`\n   */\n  mode?: 'any' | 'closest' | 'all';\n}\n\ninterface ComputePolygonOptions {\n  /**\n   * The type of polygon being computed: \"movement\", \"sight\", or \"sound\"\n   * @defaultValue `'sight'`\n   */\n  type?: 'movement' | 'sight' | 'sound';\n\n  /**\n   * An optional limited angle of emission with which to restrict polygons\n   * @defaultValue `360`\n   */\n  angle?: number;\n\n  /**\n   * The desired radial density of emission for rays, in degrees\n   * @defaultValue `6`\n   */\n  density?: number;\n\n  /**\n   * The current angle of rotation, used when the angle is limited\n   * @defaultValue `0`\n   */\n  rotation?: number;\n\n  /**\n   * Compute sight that is fully unrestricted by walls\n   * @defaultValue `false`\n   */\n  unrestricted?: boolean;\n}\n\ninterface RayCollisionsOptions {\n  /**\n   * Which collision type to check: movement, sight, sound\n   * @defaultValue `'movement'`\n   */\n  type?: 'movement' | 'sight' | 'sound';\n\n  /**\n   * Which type of collisions are returned: any, closest, all\n   * @defaultValue `'all'`\n   */\n  mode?: `any` | `closest` | `all`;\n\n  /**\n   * Internal performance tracking\n   */\n  _performance?: { tests: number };\n}\n"
    ]
  