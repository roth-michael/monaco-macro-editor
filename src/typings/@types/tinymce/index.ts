
    export default [
      "@types/tinymce/index.d.ts",
      "// Type definitions for TinyMCE 4.6\n// Project: https://github.com/tinymce/tinymce, https://github.com/tinymce/tinymce-dist\n// Definitions by: Martin Duparc <https://github.com/martinduparc>\n//                 Poul Poulsen <https://github.com/ipoul>\n//                 Nico Hartto <https://github.com/nicohartto>\n//                 Tyler Romeo <https://github.com/Parent5446>\n//                 Ashley Workman <https://github.com/CymruKakashi>\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\n// TypeScript Version: 2.3\n\n// Work In Progress\n\n/// <reference types=\"jquery\" />\n\nexport const DOM: dom.DOMUtils;\n\nexport const PluginManager: AddOnManager;\n\nexport const ScriptLoader: dom.ScriptLoader;\n\nexport const ThemeManager: AddOnManager;\n\nexport const EditorManager: EditorManager;\n\nexport const baseURL: string;\n\nexport const activeEditor: Editor;\n\nexport function create(s: string, p: {}, root?: {}): void;\n\nexport function createNS(n: string, o: {}): {};\n\nexport function each(o: {}, cb: () => void, s?: {}): void;\n\nexport function explode(s: string, d: string): void;\n\nexport function grep(a: any[], f: () => void): any[];\n\nexport function inArray(item: any, arr: any[]): number;\n\nexport function is(obj: {}, type?: string): boolean;\n\nexport function isArray(obj: {}): boolean;\n\nexport function makeMap(items: any[], delim?: string, map?: {}): {};\n\nexport function map(array: any[], callback: () => void): any[];\n\nexport function resolve(n: string, o?: {}): {};\n\nexport function toArray(obj: {}): any[];\n\nexport function trim(s: string): string;\n\nexport function walk(o: {}, f: () => void, n?: string, s?: string): void;\n\nexport function init(settings: Settings): void;\n\nexport function triggerSave(): void;\n\nexport function get(id: string | number): Editor;\n\nexport interface Settings {\n    base_url?: string;\n\n    table_toolbar?: string;\n\n    table_appearance_options?: boolean;\n\n    table_clone_elements?: string;\n\n    table_grid?: boolean;\n\n    table_tab_navigation?: boolean;\n\n    table_default_attributes?: object | string;\n\n    table_default_styles?: object | string;\n\n    table_sizing_mode?: 'fixed' | 'relative' | 'responsive' | 'auto';\n\n    table_class_list?: object[];\n\n    table_cell_class_list?: object[];\n\n    table_row_class_list?: object[];\n\n    table_advtab?: boolean;\n\n    table_cell_advtab?: boolean;\n\n    table_row_advtab?: boolean;\n\n    table_resize_bars?: boolean;\n\n    table_style_by_css?: boolean;\n\n    auto_focus?: string;\n\n    cache_suffix?: string;\n\n    content_security_policy?: string;\n\n    external_plugins?: {};\n\n    hidden_input?: boolean;\n\n    paste_data_images?: boolean;\n\n    advlist_number_styles?: string;\n\n    init_instance_callback?(editor: Editor): void;\n\n    plugins?: string | string[];\n\n    selector?: string;\n\n    setup?(edtor: Editor): void;\n\n    target?: Element;\n\n    branding?: boolean;\n\n    color_picker_callback?(callback: (hexColor: string) => void, value: string): void;\n\n    custom_ui_selector?: string;\n\n    elementpath?: boolean;\n\n    event_root?: boolean;\n\n    fixed_toolbar_container?: string;\n\n    height?: number | string;\n\n    inline?: boolean;\n\n    insert_button_items?: string;\n\n    insert_toolbar?: string;\n\n    max_height?: number;\n\n    max_width?: number;\n\n    menu?: settings.Menu;\n\n    menubar?: string | boolean;\n\n    min_height?: number | string;\n\n    min_width?: number | string;\n\n    preview_styles?: boolean | string;\n\n    removed_menuitems?: string;\n\n    resize?: boolean | string;\n\n    selection_toolbar?: string;\n\n    skin_url?: string;\n\n    skin?: false | string;\n\n    statusbar?: boolean;\n\n    theme_url?: string;\n\n    theme?: string;\n\n    toolbar?: boolean | string | string[];\n\n    width?: number | string;\n\n    body_class?: string;\n\n    body_id?: string;\n\n    content_css?: string | string[];\n\n    content_style?: string;\n\n    inline_boundaries?: boolean;\n\n    inline_boundaries_selector?: boolean;\n\n    visual_anchor_class?: string;\n\n    visual_table_class?: string;\n\n    visual?: boolean;\n\n    allow_conditional_comments?: boolean;\n\n    allow_html_in_named_anchor?: boolean;\n\n    allow_unsafe_link_target?: boolean;\n\n    convert_fonts_to_spans?: boolean;\n\n    custom_elements?: string;\n\n    doctype?: string;\n\n    element_format?: string;\n\n    encoding?: string;\n\n    entities?: string;\n\n    entity_encoding?: string;\n\n    extended_valid_elements?: string;\n\n    fix_list_elements?: boolean;\n\n    force_hex_style_colors?: boolean;\n\n    forced_root_block?: string;\n\n    forced_root_block_attrs?: {};\n\n    invalid_elements?: string;\n\n    invalid_styles?: string | {};\n\n    keep_styles?: boolean;\n\n    protect?: RegExp[];\n\n    remove_trailing_brs?: boolean;\n\n    schema?: string;\n\n    valid_children?: string;\n\n    valid_classes?: string | {};\n\n    valid_elements?: string;\n\n    valid_styles?: {};\n\n    block_formats?: string;\n\n    font_formats?: string;\n\n    fontsize_formats?: string;\n\n    formats?: {};\n\n    removeFormat?: Array<{}>;\n\n    indentation?: string;\n\n    style_formats?: Array<{}>;\n\n    style_formats_autohide?: boolean;\n\n    style_formats_merge?: boolean;\n\n    browser_spellcheck?: boolean;\n\n    gecko_spellcheck?: boolean;\n\n    automatic_uploads?: boolean;\n\n    file_browser_callback?(field_name: string, url: string, type: string, win: Window): void;\n\n    file_browser_callback_types?: string;\n\n    file_picker_callback?(callback: (filename: string, metadata: {}) => void, valud: string, meta: {}): void;\n\n    file_picker_types?: string;\n\n    images_dataimg_filter?(img: HTMLImageElement): void;\n\n    images_reuse_filename?: boolean;\n\n    images_upload_base_path?: string;\n\n    images_upload_credentials?: boolean;\n\n    images_upload_handler?(blobInfo: any, success: (msg: string) => void, failure: (msg: string) => void): void;\n\n    images_upload_url?: string;\n\n    directionality?: string;\n\n    language?: string;\n\n    language_url?: string;\n\n    allow_script_urls?: boolean;\n\n    convert_urls?: boolean;\n\n    document_base_url?: string;\n\n    relative_urls?: boolean;\n\n    remove_script_host?: boolean;\n\n    urlconverter_callback?(url: string, node: HTMLElement, on_save: boolean, name: string): void;\n\n    anchor_bottom?: string;\n\n    anchor_top?: string;\n\n    br_in_pre?: boolean;\n\n    custom_undo_redo_levels?: number;\n\n    end_container_on_empty_block?: boolean;\n\n    nowrap?: boolean;\n\n    object_resizing?: boolean | string;\n\n    type_ahead_urls?: boolean;\n\n    autosave_ask_before_unload?: boolean;\n\n    autosave_interval?: string;\n\n    autosave_prefix?: string;\n\n    autosave_restore_when_empty?: boolean;\n\n    autosave_retention?: string;\n\n    imagetools_cors_hosts?: string[];\n\n    imagetools_proxy?: string;\n\n    imagetools_toolbar?: string;\n\n    imagetools_api_key?: string;\n\n    spellchecker_rpc_url?: string;\n\n    spellchecker_language?: string;\n\n    spellchecker_languages?: string;\n\n    spellchecker_dialog?: boolean;\n\n    spellchecker_whitelist?: string[];\n\n    spellchecker_on_load?: boolean;\n\n    spellchecker_active?: boolean;\n}\n\nexport namespace settings {\n    interface Menu {\n        file?: MenuItem;\n        edit?: MenuItem;\n        insert?: MenuItem;\n        view?: MenuItem;\n        format?: MenuItem;\n        table?: MenuItem;\n        tools?: MenuItem;\n    }\n\n    interface MenuItem {\n        title: string;\n        items: string;\n    }\n}\n\nexport interface AddOnManager {\n    add(id: string, addOn: (editor: Editor, url: string) => void): Theme | Plugin;\n\n    addComponents(pluginName: string, scripts: string[]): void;\n\n    get(name: string): Theme | Plugin;\n\n    load(name: string, addOnUrl: string, success?: () => void, scope?: {}, failure?: () => void): void;\n\n    requireLangPack(name: string, languages?: string): void;\n}\n\nexport class Editor extends util.Observable {\n    constructor(id: string, settings: Settings, editorManager: EditorManager);\n\n    $: dom.DomQuery;\n\n    baseURI: util.URI;\n\n    contentCSS: string[];\n\n    contentStyles: string[];\n\n    documentBaseURI: util.URI;\n\n    dom: dom.DOMUtils;\n\n    formatter: Formatter;\n\n    id: string;\n\n    initialized: boolean;\n\n    notificationManager: notificationManager;\n\n    parser: html.DomParser;\n\n    schema: html.Schema;\n\n    selection: dom.Selection;\n\n    serializer: dom.Serializer;\n\n    settings: Settings;\n\n    theme: Theme;\n\n    undoManager: UndoManager;\n\n    windowManager: WindowManager;\n\n    addButton(name: string, settings: {}): void;\n\n    addCommand(name: string, callback: (ui: boolean, value: {}) => boolean, scope?: {}): void;\n\n    addContextToolbar(predicate: ((el: Node) => boolean) | string, items: string): void;\n\n    addMenuItem(name: string, settings: {}): void;\n\n    addQueryStateHandler(name: string, callback: () => boolean, scope?: {}): void;\n\n    addQueryValueHandler(name: string, callback: () => {}, scope?: {}): void;\n\n    addShortcut(pattern: string, desc: string, cmdFunc: string, sc?: {}): boolean;\n\n    addSidebar(name: string, settings: {}): void;\n\n    addVisual(elm?: Element): void;\n\n    convertURL(url: string, name: string, elm: string): string;\n\n    destroy(automatic?: boolean): void;\n\n    execCallback(name: string): {};\n\n    execCommand(cmd: string, ui?: boolean, value?: any, args?: {}): void;\n\n    focus(skipFocus: boolean): void;\n\n    getBody(): HTMLBodyElement;\n\n    getContainer(): Element;\n\n    getContent(args?: {}): string;\n\n    getContentAreaContainer(): Element;\n\n    getDoc(): Document;\n\n    getElement(): Element;\n\n    getLang(name: string, defaultVal?: string): void;\n\n    getParam(name: string, defaultVal?: string, type?: string): string;\n\n    getWin(): Window;\n\n    hasEventListeners(name: string): boolean;\n\n    hide(): void;\n\n    init(): void;\n\n    insertContent(content: string, args?: {}): void;\n\n    isDirty(): boolean;\n\n    isHidden(): boolean;\n\n    load(args?: {}): string;\n\n    nodeChanged(args?: {}): void;\n\n    queryCommandState(cmd: string): boolean;\n\n    queryCommandSupported(cmd: string): boolean;\n\n    queryCommandValue(cmd: string): {};\n\n    remove(): void;\n\n    render(): void;\n\n    save(args: {}): string;\n\n    setContent(content: string, args?: {}): string;\n\n    setDirty(state: boolean): void;\n\n    setMode(mode: string): void;\n\n    setProgressState(state: boolean, time: number): boolean;\n\n    show(): void;\n\n    translate(text: string): string;\n\n    uploadImages(callback: () => void): Promise<any>;\n}\n\nexport interface EditorCommands {\n    addCommands(command_list: {}, type?: string): void;\n\n    execCommand(command: string, ui?: boolean, value?: {}, args?: {}): boolean;\n\n    queryCommandState(command: string): boolean | number;\n\n    queryCommandSupported(command: string): boolean;\n\n    queryCommandValue(command: string): {};\n}\n\nexport interface EditorManager extends util.Observable {\n    $: dom.DomQuery;\n\n    activeEditor: Editor;\n\n    baseURI: util.URI;\n\n    baseURL: string;\n\n    documentBaseURL: string;\n\n    editors: Editor[];\n\n    i18n: {};\n\n    majorVersion: string;\n\n    minorVersion: string;\n\n    releaseDate: string;\n\n    suffix: string;\n\n    add(editor: Editor): Editor;\n\n    addI18n(code: string, items: {}): void;\n\n    createEditor(id: string, settings: {}): Editor;\n\n    execCommand(cmd: string, ui?: boolean, value?: string): boolean;\n\n    get(id: string): Editor;\n\n    init(settings: Settings): Promise<Editor>;\n\n    overrideDefaults(defaultSettings: {}): void;\n\n    remove(selector: Editor): Editor;\n\n    setActive(editor: Editor): void;\n\n    translate(text: string): string;\n\n    triggerSave(): void;\n}\n\nexport interface Env {\n    android: boolean;\n\n    ceFalse: boolean;\n\n    contentEditable: boolean;\n\n    documentMode: boolean;\n\n    fileApi: boolean;\n\n    gecko: boolean;\n\n    iOS: boolean;\n\n    ie: boolean;\n\n    mac: boolean;\n\n    noCaretAfter: boolean;\n\n    opera: boolean;\n\n    range: boolean;\n\n    transparentSrc: boolean;\n\n    webKit: boolean;\n}\n\nexport namespace Events {\n    interface Event {\n        type: string;\n\n        target: string;\n\n        isDefaultPrevented(): boolean;\n\n        isImmediatePropagationStopped(): boolean;\n\n        isPropagationStopped(): boolean;\n\n        preventDefault(): void;\n\n        stopImmediatePropagation(): void;\n\n        stopPropagation(): void;\n    }\n\n    interface FocusBlurEvent extends Event {\n        blurredEditor: Editor;\n    }\n\n    interface ContentEvent extends Event {\n        format: string;\n\n        set: boolean;\n\n        content: string;\n    }\n\n    interface ProcessEvent extends Event {\n        content: string;\n\n        forced_root_block: string;\n\n        format: string;\n\n        get: boolean;\n\n        get_inner: boolean;\n\n        node: Node;\n\n        selection: true;\n    }\n\n    interface NodeChangeEvent extends Event {\n        element: Node;\n\n        parents: Node[];\n\n        selectionChange: boolean;\n    }\n\n    interface UndoRedoEvent extends Event {\n        level: {};\n    }\n\n    interface ChangeEvent extends Event {\n        lastLevel: {};\n\n        level: {};\n    }\n\n    interface CommandEvent extends Event {\n        command: string;\n\n        ui: boolean;\n\n        value: string;\n    }\n}\n\nexport class FocusManager {\n    constructor();\n    static isEditorUIElement(elm: Element): boolean;\n}\n\nexport interface Formatter {\n    apply(name: string, vars?: {}, node?: html.Node): void;\n\n    canApply(name: string): boolean;\n\n    formatChanged(formats: string, callback: () => void, similar: boolean): void;\n\n    get(name?: string): any[] | {};\n\n    getCssText(format: string): string;\n\n    match(name: string, vars?: {}, node?: html.Node): boolean;\n\n    matchAll(names: any[], vars?: {}): any[];\n\n    matchNode(node: html.Node, name: string, vars: {}, similar: boolean): {};\n\n    register(name: {}, format?: {}): void;\n\n    remove(name: string, vars?: {}, node?: html.Node): void;\n\n    toggle(name: string, vars?: {}, node?: html.Node): void;\n\n    unregister(name: string): void;\n}\n\nexport class Formatter implements Formatter {\n    constructor(ed: Editor);\n}\n\nexport interface Shortcuts {\n    add(pattern: string, desc: string, cmdFunc: () => void | string, scope?: {}): boolean;\n\n    remove(pattern: string): boolean;\n}\n\nexport interface Theme {\n    renderUI(obj: {}): {};\n}\n\nexport interface UndoManager {\n    add(level?: {}, event?: DocumentEvent): {};\n\n    beforeChange(): void;\n\n    clear(): void;\n\n    extra(callback1: () => void, callback2: () => void): void;\n\n    hasRedo(): boolean;\n\n    hasUndo(): boolean;\n\n    ignore(callback: () => void): void;\n\n    redo(): {};\n\n    transact(callback: () => void): {};\n\n    undo(): {};\n}\n\nexport interface WindowManager {\n    alert(message: string, callback: () => void, scope?: {}): void;\n\n    close(): void;\n\n    confirm(message: string, callback: () => void, scope?: {}): void;\n\n    getParams(): {};\n\n    getWindows(): Window[];\n\n    open(args: {}, params: {}): void;\n\n    setParams(params: {}): void;\n}\n\nexport interface notificationManager {\n    close(): void;\n\n    getNotifications(): Array<{}>;\n\n    open(args?: {}): void;\n}\n\nexport namespace ui {\n    interface ControlSettings {\n        menu: Menu;\n    }\n\n    interface Collection {}\n\n    interface Container {\n        add(items: any): Collection;\n        items(): Collection;\n    }\n\n    interface Moveable {\n        moveRel(elm: Node, rel: string): Control;\n    }\n\n    interface FloatPanel extends Control, Moveable {}\n\n    interface Menu extends FloatPanel, Control, Container {}\n\n    interface Factory {\n        create(settings: any): Control;\n    }\n\n    class Control {\n        constructor();\n\n        $el: JQuery;\n        on(name: string, callback: string): Control;\n        tooltip(): Control;\n        settings: ControlSettings;\n        disabled(state: boolean): void;\n        active(state: boolean): void;\n    }\n}\n\nexport namespace dom {\n    interface BookmarkManager {\n        getBookmark(type?: number, normalized?: boolean): {};\n\n        isBookmarkNode(node: HTMLElement): boolean;\n\n        moveToBookmark(bookmark: {}): boolean;\n    }\n\n    interface DOMUtils {\n        add<T>(parentElm: string, name: string, attrs?: {}, html?: string, create?: boolean): Element | T[];\n\n        addClass<T>(elm: string, cls: string): string | T[];\n\n        addStyle(cssText: string): void;\n\n        bind(target: Element, name: string, func: () => void, scope?: {}): () => void;\n\n        create(name: string, attrs?: {}, html?: string): Element;\n\n        createFragment(html: string): DocumentFragment;\n\n        createHTML(name: string, attrs?: {}, html?: string): string;\n\n        createRng(): Range;\n\n        decode(s: string): string;\n\n        destroy(): void;\n\n        encode(text: string): string;\n\n        findCommonAncestor(a: Element, b: Element): Element;\n\n        fire(target: Node, name: string, evt: {}): Event;\n\n        get(n: string): Element;\n\n        getAttrib(elm: string, name: string, defaultVal: string): string;\n\n        getAttribs(elm?: HTMLElement): NodeList;\n\n        getNext(node: Node, selector: string): Node;\n\n        getOuterHTML(elm: string): string;\n\n        getParent(node: Node, selector: any, root?: Node): Node;\n\n        getParents<T>(node: Node, selector: () => void, root?: Node): T[];\n\n        getPos(elm: Element, rootElm?: Element): {};\n\n        getPrev(node: Node, selector: string): Node;\n\n        getRect(elm: Element): {};\n\n        getRoot(): Element;\n\n        getSize(elm: Element): {};\n\n        getStyle(elm: string, name: string, computed: boolean): string;\n\n        getViewPort(win?: Window): {};\n\n        hasClass(elm: string, cls: string): boolean;\n\n        hide(elm: string): void;\n\n        insertAfter<T>(node: Element, referenceNode: Element): Element | T[];\n\n        is(elm: Node, selector: string): boolean;\n\n        isBlock(node: Node): boolean;\n\n        isEmpty(elements?: {}): boolean;\n\n        isHidden(elm: string): boolean;\n\n        loadCSS(url: string): void;\n\n        nodeIndex(node: Node, normalized?: boolean): number;\n\n        parseStyle(cssText: string): {};\n\n        remove<T>(node: string | Element, keepChildren?: boolean): Element | T[];\n\n        removeAllAttribs(e: Element): void;\n\n        removeClass<T>(elm: string, cls: string): string | T[];\n\n        rename(elm: Element, name: string): Element;\n\n        replace(newElm: Element, oldElm: Element, keepChildren?: boolean): void;\n\n        run<T>(elm: string, func: () => void, scope?: {}): {} | T[];\n\n        select<T>(selector: string, scope?: {}): T[];\n\n        serializeStyle(styles: {}, name?: string): string;\n\n        setAttrib(elm: Element, name: string, value: string): void;\n\n        setAttribs(elm: Element, attrs: {}): void;\n\n        setHTML(elm: Element, html: string): void;\n\n        setOuterHTML(elm: Element, html: {}): void;\n\n        setStyle(elm: string, name: string, value: string): void;\n\n        setStyles(elm: Element, styles: {}): void;\n\n        show(elm: string): void;\n\n        split(parentElm: Element, splitElm: Element, replacementElm?: Element): Element;\n\n        toHex(rgbVal: string): string;\n\n        toggleClass(elm: Element, cls: string, state?: string): void;\n\n        unbind<T>(target: Element, name: string, func: () => void): boolean | T[];\n\n        uniqueId(prefix?: string): string;\n    }\n\n    class DOMUtils implements DOMUtils {\n        constructor(doc: Document, settings?: {});\n    }\n\n    interface DomQuery {\n        add<T>(items: T[], sort?: boolean): DomQuery;\n\n        addClass(className: string): DomQuery;\n\n        after(content: string): DomQuery;\n\n        append(content: string): DomQuery;\n\n        appendTo(val: string): DomQuery;\n\n        attr(name: string, value?: string): DomQuery | string;\n\n        before(content: string): DomQuery;\n\n        children(node: Element | string): DomQuery;\n\n        clone(): DomQuery;\n\n        closest(selector: string): DomQuery;\n\n        contents(node: Element | string): DomQuery;\n\n        css(name: string, value?: string): DomQuery | string;\n\n        each(callback: () => void): DomQuery;\n\n        each(obj: {}, callback: () => void): void;\n\n        empty(): DomQuery;\n\n        eq(index: number): DomQuery;\n\n        extend(target: {}, object: {}): {};\n\n        filter(selector: string): DomQuery;\n\n        find(selector: string): DomQuery;\n\n        first(): DomQuery;\n\n        grep<T>(array: T[], callback: () => void): T[];\n\n        hasClass(className: string): boolean;\n\n        hide(): DomQuery;\n\n        html(value?: string): DomQuery | string;\n\n        inArray<T>(item: {}, array: T[]): number;\n\n        is(selector: string): boolean;\n\n        isArray(array: {}): boolean;\n\n        last(): DomQuery;\n\n        makeArray<T>(object: {}): T[];\n\n        next(node: Element | string): DomQuery;\n\n        nextUntil(node: Element | string, until: string): DomQuery;\n\n        off(name?: string, callback?: () => void): DomQuery;\n\n        offset(offset?: {}): {} | DomQuery;\n\n        on(name: string, callback: () => void): DomQuery;\n\n        parent(node: Element | string): DomQuery;\n\n        parents(node: Element | string): DomQuery;\n\n        parentsUntil(node: Element | string, until: string): DomQuery;\n\n        prepend(content: string): DomQuery;\n\n        prependTo(val: string): DomQuery;\n\n        prev(node: Element | string): DomQuery;\n\n        prevUntil(node: Element | string, until: string): DomQuery;\n\n        remove(): DomQuery;\n\n        removeAttr(name: string): DomQuery | string;\n\n        removeClass(className: string): DomQuery;\n\n        replaceWith(content: string): DomQuery;\n\n        show(): DomQuery;\n\n        slice(start: number, end?: number): DomQuery;\n\n        text(value?: string): DomQuery | string;\n\n        toArray<T>(): T[];\n\n        toggleClass(className: string, state?: boolean): DomQuery;\n\n        trigger(name: string): DomQuery;\n\n        trim(str: string): string;\n\n        unwrap(): DomQuery;\n\n        wrap(content: string): DomQuery;\n\n        wrapAll(content: string): DomQuery;\n\n        wrapInner(content: string): DomQuery;\n    }\n\n    class DomQuery implements DomQuery {\n        constructor(selector?: string, context?: Document);\n    }\n\n    interface EventUtils {\n        bind(target: {}, names: string, callback: () => void, scope: {}): () => void;\n\n        clean(target: {}): EventUtils;\n\n        fire(target: {}, name: string, args?: {}): EventUtils;\n\n        unbind(target: {}, names?: string, callback?: () => void): EventUtils;\n    }\n\n    interface RangeUtils {\n        compareRanges(rng1: Range, rng2: Range): boolean;\n\n        getCaretRangeFromPoint(clientX: number, clientY: number, doc: Document): Range;\n    }\n\n    interface ScriptLoader {\n        add(url: string, success?: () => void, scope?: {}, failure?: () => void): void;\n\n        isDone(url: string): boolean;\n\n        load(url: string, callback1?: () => void, callback2?: () => void): void;\n\n        loadQueue(success?: () => void, failure?: () => void, scope?: {}): void;\n\n        loadScripts(scripts: string[], callback1?: () => void, scope?: {}, callback2?: () => void): void;\n\n        markDone(url: string): void;\n    }\n\n    interface Selection {\n        collapse(toStart?: boolean): void;\n\n        getBookmark(type?: number, normalized?: boolean): {};\n\n        getContent(args?: {}): string;\n\n        getEnd(real?: boolean): Element;\n\n        getNode(): Element;\n\n        getRng(w3c: boolean): Range;\n\n        getSel(): Selection;\n\n        getStart(real?: boolean): Element;\n\n        isCollapsed(): boolean;\n\n        moveToBookmark(bookmark: {}): boolean;\n\n        select(node: Element, content?: boolean): Element;\n\n        selectorChanged(selector: string, callback: () => void): void;\n\n        setContent(content: string, args?: {}): void;\n\n        setCursorLocation(node?: Node, offset?: number): void;\n\n        setNode(elm: Element): Element;\n\n        setRng(rng: Range, forward?: boolean): void;\n    }\n\n    class Selection implements Selection {\n        constructor(dom: DOMUtils, win: Window, editor: Editor, serializer: Serializer);\n    }\n\n    interface Serializer {\n        addAttributeFilter(callback: () => void): void;\n\n        addNodeFilter(callback: () => void): void;\n\n        addRules(rules: string): void;\n\n        addTempAttr(name: string): void;\n\n        serialize(node: HTMLElement, args: {}): void;\n\n        setRules(rules: string): void;\n    }\n\n    class Serializer implements Serializer {\n        constructor(settings: {}, editor?: Editor);\n    }\n\n    interface TreeWalker {\n        current(): html.Node;\n\n        next(): html.Node;\n\n        prev(): html.Node;\n    }\n}\n\nexport class TreeWalker implements TreeWalker {\n    constructor(startNode: html.Node, rootNode: html.Node);\n}\n\nexport namespace geom {\n    interface Rect {\n        clamp(rect: Rect, clampRect: Rect, fixedSize: boolean): Rect;\n\n        create(x: number, y: number, w: number, h: number): Rect;\n\n        findBestRelativePosition(rect: Rect, targetRect: Rect, constrainRect: Rect, rels: any[]): void;\n\n        fromClientRect(clientRect: ClientRect): Rect;\n\n        inflate(rect: Rect, w: number, h: number): Rect;\n\n        intersect(rect: Rect, cropRect: Rect): Rect;\n\n        relativePosition(rect: Rect, targetRect: Rect, rel: string): void;\n    }\n}\n\nexport namespace html {\n    interface DomParser {\n        addAttributeFilter(attributes: string, callback: () => void): void;\n\n        addNodeFilter(attributes: string, callback: () => void): void;\n\n        filterNode(node: Node): Node;\n\n        parse(html: string, args?: {}): Node;\n    }\n\n    class DomParser implements DomParser {\n        constructor(settings: {}, schema: Schema);\n    }\n\n    interface Entities {\n        decode(text: string): string;\n\n        encodeAllRaw(text: string): string;\n\n        encodeNamed(text: string, attr?: boolean, entities?: {}): string;\n\n        encodeNumeric(text: string, attr?: boolean): string;\n\n        encodeRaw(text: string, attr?: boolean): string;\n\n        getEncodeFunc(name: string, entities?: string): () => void;\n    }\n\n    interface Node {\n        append(node: Node): Node;\n\n        attr(name: string, value?: string): string | Node;\n\n        clone(): Node;\n\n        create(name: string, attrs: {}): void;\n\n        empty(): Node;\n\n        getAll(name: string): Node[];\n\n        insert(node: Node, ref_node: Node, before?: boolean): Node;\n\n        isEmpty(elements: {}): boolean;\n\n        remove(): Node;\n\n        replace(node: Node): Node;\n\n        unwrap(): void;\n\n        walk(prev?: boolean): Node;\n\n        wrap(wrapperNode: Node): Node;\n    }\n\n    class Node implements Node {\n        constructor(name: string, type: number);\n    }\n\n    interface SaxParser {\n        parse(html: string): void;\n    }\n\n    class SaxParser implements SaxParser {\n        constructor(settings: {}, schema: Schema);\n    }\n\n    interface Schema {\n        addCustomElements(custom_elements: string): void;\n\n        addValidChildren(valid_children: string): void;\n\n        addValidElements(valid_elements: string): void;\n\n        getBlockElements(): { [name: string]: {} };\n\n        getBoolAttrs(): { [name: string]: {} };\n\n        getCustomElements(): { [name: string]: {} };\n\n        getElementRule(name: string): {};\n\n        getInvalidStyles(): void;\n\n        getMoveCaretBeforeOnEnterElements(): { [name: string]: {} };\n\n        getNonEmptyElements(): { [name: string]: {} };\n\n        getSelfClosingElements(): { [name: string]: {} };\n\n        getShortEndedElements(): { [name: string]: {} };\n\n        getSpecialElements(): { [name: string]: {} };\n\n        getTextBlockElements(): { [name: string]: {} };\n\n        getTextInlineElements(): { [name: string]: {} };\n\n        getValidClasses(): void;\n\n        getValidStyles(): void;\n\n        getWhiteSpaceElements(): { [name: string]: {} };\n\n        isValid(name: string, attr?: string): boolean;\n\n        isValidChild(name: string, child: string): boolean;\n\n        setValidElements(valid_elements: string): void;\n    }\n\n    class Schema implements Schema {\n        constructor(settings: {});\n    }\n\n    interface Serializer {\n        serialize(node: Node): string;\n    }\n\n    class Serializer implements Serializer {\n        constructor(settings: {}, schema: Schema);\n    }\n\n    interface Styles {\n        parse(css: string): {};\n\n        serialize(styles: {}, elementName: string): string;\n\n        toHex(color: string): string;\n    }\n\n    interface Writer {\n        cdata(text: string): void;\n\n        doctype(text: string): void;\n\n        end(name: string): void;\n\n        getContent(): string;\n\n        pi(name: string, text: string): void;\n\n        reset(): void;\n\n        start(name: string, attrs?: any[], empty?: boolean): void;\n\n        text(text: string, raw: boolean): void;\n    }\n}\n\nexport class Writer implements Writer {\n    constructor(settings: {});\n}\n\nexport namespace util {\n    interface Color {\n        parse(value: {}): Color;\n\n        toHex(): string;\n\n        toHsv(): {};\n\n        toRgb(): {};\n    }\n\n    class Color implements Color {\n        constructor(value: string | {});\n    }\n\n    interface Delay {\n        clearInterval(interval: number): void;\n\n        clearTimeout(timeout: number): void;\n\n        debounce(callback: () => void, time: number): () => void;\n\n        requestAnimationFrame(callback: () => void, element?: HTMLElement): void;\n\n        setEditorInterval(callback: () => void, time: number): number;\n\n        setEditorTimeout(editor: Editor, callback: () => void, time: number): number;\n\n        setInterval(callback: () => void, time: number): number;\n\n        setTimeout(callback: () => void, time: number): number;\n    }\n\n    interface EventDispatcher {\n        fire(name: string, args?: {}): {};\n\n        has(name: string): boolean;\n\n        isNative(name: string): boolean;\n\n        off(name: string, callback?: () => void): {};\n\n        on(name: string, callback: () => void, first?: boolean): {};\n\n        once(name: string, callback: () => void, first: boolean): {};\n    }\n\n    interface i18n {\n        rtl: boolean;\n\n        add(code: string, items: Array<{}>): void;\n\n        getCode(): string;\n\n        setCode(newCode: string): void;\n\n        translate(text: string): string;\n    }\n\n    interface JSON {\n        parse(s: string): {};\n\n        serialize(obj: {}, quote?: string): string;\n    }\n\n    interface JSONRequest {\n        send(args: {}): void;\n\n        sendRPC(o: {}): void;\n    }\n\n    interface LocalStorage {\n        length: number;\n\n        clear(): void;\n\n        getItem(key: string): string;\n\n        key(index: number): string;\n\n        removeItem(key: string): void;\n\n        setItem(key: string, value: string): void;\n    }\n\n    class Observable {\n        fire(name: string, args?: {}, bubble?: boolean): {};\n\n        hasEventListeners(name: string): boolean;\n\n        off(name?: string, callback?: () => void): {};\n\n        on(name: string, callback: (event: any) => void, first?: boolean): {};\n\n        once(name: string, callback: (event: any) => void): {};\n    }\n\n    interface Tools {\n        create(s: string, p: {}, root?: {}): void;\n\n        createNS(n: string, o?: {}): {};\n\n        each(o: {}, cb: () => void, s?: {}): void;\n\n        explode(s: string, d: string): void;\n\n        grep<T>(a: T[], f: () => void): T[];\n\n        inArray<T>(item: T, arr: T[]): number;\n\n        is(obj: {}, type: string): boolean;\n\n        isArray(obj: {}): boolean;\n\n        makeMap<T>(items: T[], delim?: string, map?: {}): {};\n\n        map<T, S>(array: T[], callback: (c: T) => S): S[];\n\n        resolve(n: string, o?: {}): {};\n\n        toArray<T>(obj: {}): T[];\n\n        trim(s: string): string;\n\n        walk(o: {}, f: () => void, n?: string, s?: string): void;\n    }\n\n    interface URI {\n        getURI(noProtoHost: boolean): URI;\n\n        isSameOrigin(uri: URI): boolean;\n\n        setPath(path: string): void;\n\n        toAbsPath(base: string, path: string): void;\n\n        toAbsolute(uri: string, noHost: boolean): string;\n\n        toRelPath(base: string, path: string): void;\n\n        toRelative(uri: string): string;\n    }\n\n    class URI implements URI {\n        constructor(url: string, settings?: {});\n    }\n\n    interface XHR {\n        fire(name: string, args?: {}, bubble?: boolean): {};\n\n        hasEventListeners(name: string): boolean;\n\n        off(name?: string, callback?: () => void): {};\n\n        on(name: string, callback: () => void, first?: boolean): {};\n\n        once(name: string, callback: () => void): {};\n\n        send(settings: {}): void;\n    }\n}\n"
    ]
  