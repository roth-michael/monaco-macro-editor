
    export default [
      "@league-of-foundry-developers/foundry-vtt-types/src/foundry/foundry.js/pixi/containers/placeableObjects/token.d.ts",
      "import { ConfiguredDocumentClass, ConfiguredDocumentClassForName } from '../../../../../types/helperTypes';\nimport { DocumentModificationOptions } from '../../../../common/abstract/document.mjs';\n\ndeclare global {\n  /**\n   * A Token is an implementation of PlaceableObject which represents an Actor within a viewed Scene on the game canvas.\n   * @see TokenDocument\n   * @see TokenLayer\n   */\n  class Token extends PlaceableObject<InstanceType<ConfiguredDocumentClass<typeof TokenDocument>>> {\n    /**\n     * A Ray which represents the Token's current movement path\n     */\n    protected _movement: Ray | null;\n\n    /**\n     * An Object which records the Token's prior velocity dx and dy\n     * This can be used to determine which direction a Token was previously moving\n     */\n    protected _velocity: Token.Velocity;\n\n    /**\n     * The Token's most recent valid position\n     */\n    protected _validPosition: { x: number; y: number };\n\n    /**\n     * Track the set of User entities which are currently targeting this Token\n     */\n    targeted: Set<User>;\n\n    /**\n     * A reference to the PointSource object which defines this vision source area of effect\n     */\n    vision: PointSource;\n\n    /**\n     * A reference to the PointSource object which defines this light source area of effect\n     */\n    light: PointSource;\n\n    /** @override */\n    static get embeddedName(): 'Token';\n\n    /**\n     * Establish an initial velocity of the token based on it's direction of facing.\n     * Assume the Token made some prior movement towards the direction that it is currently facing.\n     */\n    protected _getInitialVelocity(): Token.Velocity;\n\n    /**\n     * A convenient reference to the Actor object associated with the Token embedded document.\n     */\n    get actor(): this['document']['actor'];\n\n    /**\n     * A convenient reference for whether the current User has full control over the Token document.\n     */\n    get owner(): boolean;\n\n    get isOwner(): boolean;\n\n    /**\n     * A boolean flag for whether the current game User has observer permission for the Token\n     */\n    get observer(): boolean;\n\n    /**\n     * Is the HUD display active for this token?\n     */\n    get hasActiveHUD(): boolean;\n\n    /**\n     * Convenience access to the token's nameplate string\n     * @remarks\n     * This is actually a getter that returns data.name\n     */\n    readonly name: string;\n\n    /**\n     * Translate the token's grid width into a pixel width based on the canvas size\n     */\n    get w(): number;\n\n    /**\n     * Translate the token's grid height into a pixel height based on the canvas size\n     */\n    get h(): number;\n\n    /**\n     * The Token's current central position\n     */\n    get center(): ReturnType<this['getCenter']>;\n\n    /**\n     * An indicator for whether or not this token is currently involved in the active combat encounter.\n     */\n    get inCombat(): boolean;\n\n    /**\n     * Return a reference to a Combatant that represents this Token, if one is present in the current encounter.\n     */\n    get combatant(): InstanceType<ConfiguredDocumentClass<typeof Combatant>> | null;\n\n    /**\n     * An indicator for whether the Token is currently targeted by the active game User\n     */\n    get isTargeted(): boolean;\n\n    /**\n     * Determine whether the Token is visible to the calling user's perspective.\n     * Hidden Tokens are only displayed to GM Users.\n     * Non-hidden Tokens are always visible if Token Vision is not required.\n     * Controlled tokens are always visible.\n     * All Tokens are visible to a GM user if no Token is controlled.\n     *\n     * @see {@link SightLayer#testVisibility}\n     */\n    get isVisible(): boolean;\n\n    /**\n     * Test whether the Token has sight (or blindness) at any radius\n     */\n    get hasSight(): boolean;\n\n    /**\n     * Test whether the Token emits light (or darkness) at any radius\n     */\n    get emitsLight(): boolean;\n\n    /**\n     * Test whether the Token has a limited angle of vision or light emission which would require sight to update on Token rotation\n     */\n    get hasLimitedVisionAngle(): boolean;\n\n    /**\n     * Translate the token's sight distance in units into a radius in pixels.\n     * @returns The sight radius in pixels\n     */\n    get dimRadius(): number;\n\n    /**\n     * Translate the token's bright light distance in units into a radius in pixels.\n     * @returns The bright radius in pixels\n     */\n    get brightRadius(): number;\n\n    /**\n     * The named identified for the source object associated with this Token\n     */\n    get sourceId(): string;\n\n    /**\n     * Update the light and vision source objects associated with this Token\n     * @param defer       - Defer refreshing the SightLayer to manually call that refresh later.\n     *                      (default: `false`)\n     * @param deleted     - Indicate that this light source has been deleted.\n     *                      (default: `false`)\n     * @param noUpdateFog - Never update the Fog exploration progress for this update.\n     *                      (default: `false`)\n     */\n    updateSource({ defer, deleted, noUpdateFog }?: { defer?: boolean; deleted?: boolean; noUpdateFog?: boolean }): void;\n\n    /**\n     * Test whether this Token is a viable vision source for the current User\n     */\n    protected _isVisionSource(): boolean;\n\n    /** @override */\n    draw(): Promise<this>;\n\n    /**\n     * Apply initial sanitizations to the provided input data to ensure that a Token has valid required attributes.\n     */\n    protected _cleanData(): void;\n\n    /**\n     * Draw resource bars for the Token\n     */\n    protected _drawAttributeBars(): PIXI.Container;\n\n    /**\n     * Draw the Sprite icon for the Token\n     */\n    protected _drawIcon(): Promise<PIXI.Sprite>;\n\n    /**\n     * Update display of the Token, pulling latest data and re-rendering the display of Token components\n     */\n    refresh(): this;\n\n    /**\n     * Draw the Token border, taking into consideration the grid type and border color\n     */\n    protected _refreshBorder(): void;\n\n    /**\n     * Get the hex color that should be used to render the Token border\n     * @returns The hex color used to depict the border color\n     */\n    protected _getBorderColor(): number | null;\n\n    /**\n     * Refresh the target indicators for the Token.\n     * Draw both target arrows for the primary User as well as indicator pips for other Users targeting the same Token.\n     */\n    protected _refreshTarget(): void;\n\n    /**\n     * Refresh the display of Token attribute bars, rendering latest resource data\n     * If the bar attribute is valid (has a value and max), draw the bar. Otherwise hide it.\n     */\n    drawBars(): void;\n\n    /**\n     * Draw a single resource bar, given provided data\n     * @param number - The Bar number\n     * @param bar    - The Bar container\n     * @param data   - Resource data for this bar\n     */\n    protected _drawBar(number: number, bar: PIXI.Graphics, data: ReturnType<Token['getBarAttribute']>): void;\n\n    /**\n     * Draw the token's nameplate as a text object\n     * @returns The Text object for the Token nameplate\n     */\n    protected _drawNameplate(): PreciseText;\n\n    /**\n     * Draw a text tooltip for the token which can be used to display Elevation or a resource value\n     */\n    drawTooltip(): void;\n\n    /**\n     * Return the text which should be displayed in a token's tooltip field\n     */\n    protected _getTooltipText(): string;\n\n    protected _getTextStyle(): PIXI.TextStyle;\n\n    /**\n     * Draw the active effects and overlay effect icons which are present upon the Token\n     */\n    drawEffects(): Promise<void>;\n\n    /**\n     * Draw the overlay effect icon\n     */\n    protected _drawOverlay({ src, tint }?: { src?: string; tint?: number }): Promise<void>;\n\n    /**\n     * Draw a status effect icon\n     */\n    protected _drawEffect(src: string, i: number, bg: PIXI.Graphics, w: number, tint: number): Promise<void>;\n\n    /**\n     * Helper method to determine whether a token attribute is viewable under a certain mode\n     * @param mode - The mode from CONST.TOKEN_DISPLAY_MODES\n     * @returns Is the attribute viewable?\n     */\n    protected _canViewMode(mode: foundry.CONST.TokenDisplayMode): boolean;\n\n    /**\n     * Animate Token movement along a certain path which is defined by a Ray object\n     * @param ray - The path along which to animate Token movement\n     */\n    animateMovement(ray: Ray): Promise<void>;\n\n    /**\n     * Animate the continual revealing of Token vision during a movement animation\n     */\n    protected _onMovementFrame(\n      dt: number,\n      anim: Array<{\n        context: unknown;\n        name: string | null;\n        duration: number;\n        ontick: (dt: number, attributes: CanvasAnimation.Attribute[]) => void;\n      }>,\n      config: { fog?: boolean; sound?: boolean; source?: boolean }\n    ): void;\n\n    /**\n     * Update perception each frame depending on the animation configuration\n     * @param source - (default: `false`)\n     * @param sound  - (default: `false`)\n     * @param fog    - (default: `false`)\n     */\n    protected _animatePerceptionFrame({\n      source,\n      sound,\n      fog\n    }?: {\n      source?: boolean;\n      sound?: boolean;\n      fog?: boolean;\n    }): void;\n\n    /**\n     * Terminate animation of this particular Token\n     */\n    stopAnimation(): void;\n\n    /**\n     * Check for collision when attempting a move to a new position\n     * @param destination - The destination point of the attempted movement\n     * @returns A true/false indicator for whether the attempted movement caused a collision\n     */\n    checkCollision(destination: Point): boolean;\n\n    /**\n     * @param releaseOthers - (default: `true`)\n     * @param pan           - (default: `false`)\n     */\n    protected _onControl({ releaseOthers, pan }?: { releaseOthers?: boolean; pan?: boolean }): void;\n\n    /** @override */\n    protected _onRelease(\n      options: PlaceableObject.ReleaseOptions\n    ): Promise<InstanceType<ConfiguredDocumentClass<typeof TokenDocument>>> | undefined;\n\n    /**\n     * Get the center-point coordinate for a given grid position\n     * @param x - The grid x-coordinate that represents the top-left of the Token\n     * @param y - The grid y-coordinate that represents the top-left of the Token\n     * @returns The coordinate pair which represents the Token's center at position (x, y)\n     */\n    getCenter(\n      x: number,\n      y: number\n    ): {\n      x: number;\n      y: number;\n    };\n\n    /**\n     * Set the token's position by comparing its center position vs the nearest grid vertex\n     * Return a Promise that resolves to the Token once the animation for the movement has been completed\n     * @param x       - The x-coordinate of the token center\n     * @param y       - The y-coordinate of the token center\n     * @param options - Additional options which configure the token movement\n     *                  (defaultValue: `{}`)\n     * @returns The Token after animation has completed\n     */\n    setPosition(x: number, y: number, options?: PositionOptions): Promise<this>;\n\n    /**\n     * Update the Token velocity auto-regressively, shifting increasing weight towards more recent movement\n     * Employ a magic constant chosen to minimize (effectively zero) the likelihood of trigonometric edge cases\n     * @param ray - The proposed movement ray\n     * @returns An updated velocity with directional memory\n     */\n    protected _updateVelocity(ray: Ray): Token.Velocity;\n\n    /**\n     * Set this Token as an active target for the current game User\n     * @param targeted       - Is the Token now targeted?\n     *                         (default: `true`)\n     * @param user           - Assign the token as a target for a specific User\n     *                         (default: `null` which will use the current user)\n     * @param releaseOthers  - Release other active targets for the same player?\n     *                         (default: `true`)\n     * @param groupSelection - Is this target being set as part of a group selection workflow?\n     *                         (default: `false`)\n     */\n    setTarget(\n      targeted?: boolean,\n      {\n        user,\n        releaseOthers,\n        groupSelection\n      }?: {\n        user?: InstanceType<ConfiguredDocumentClass<typeof User>> | null;\n        releaseOthers?: boolean;\n        groupSelection?: boolean;\n      }\n    ): void;\n\n    /**\n     * Add or remove the currently controlled Tokens from the active combat encounter\n     * @param combat - A specific combat encounter to which this Token should be added\n     * @returns The Token which initiated the toggle\n     */\n    toggleCombat(combat?: InstanceType<ConfiguredDocumentClass<typeof Combat>>): Promise<this>;\n\n    /**\n     * Toggle an active effect by it's texture path.\n     * Copy the existing Array in order to ensure the update method detects the data as changed.\n     *\n     * @param effect  - The texture file-path of the effect icon to toggle on the Token.\n     * @param options - Additional optional arguments which configure how the effect is handled.\n     *                  (defaultValue: `{}`)\n     * @returns Was the texture applied (true) or removed (false)\n     */\n    toggleEffect(\n      effect: string | ConstructorParameters<ConfiguredDocumentClassForName<'ActiveEffect'>>[0],\n      options?: EffectToggleOptions\n    ): Promise<boolean>;\n\n    /**\n     * A helper function to toggle a status effect which includes an Active Effect template\n     */\n    protected _toggleActiveEffect(\n      effectData: ConstructorParameters<ConfiguredDocumentClassForName<'ActiveEffect'>>[0],\n      { overlay }?: { overlay?: boolean }\n    ): Promise<boolean>;\n\n    /**\n     * A helper function to toggle the overlay status icon on the Token\n     */\n    protected _toggleOverlayEffect(texture: string, { active }?: { active: boolean }): Promise<this>;\n\n    /**\n     * Toggle the visibility state of any Tokens in the currently selected set\n     * @returns A Promise which resolves to the updated Token documents\n     */\n    toggleVisibility(): Promise<InstanceType<ConfiguredDocumentClass<typeof TokenDocument>>[]>;\n\n    /**\n     * Return the token's sight origin, tailored for the direction of their movement velocity to break ties with walls\n     */\n    getSightOrigin(): {\n      x: number;\n      y: number;\n    };\n\n    /**\n     * A generic transformation to turn a certain number of grid units into a radius in canvas pixels.\n     * This function adds additional padding to the light radius equal to half the token width.\n     * This causes light to be measured from the outer token edge, rather than from the center-point.\n     * @param units - The radius in grid units\n     * @returns The radius in canvas units\n     */\n    getLightRadius(units: number): number;\n\n    /** @override */\n    protected _getShiftedPosition(dx: number, dy: number): { x: number; y: number };\n\n    /**\n     * Extend the PlaceableObject.rotate method to prevent rotation if the Token is in the midst of a movement animation\n     * @returns Actually a Promise<void>\n     */\n    rotate(angle: number, snap: number): Promise<this>;\n\n    /** @override */\n    protected _onCreate(\n      options: InstanceType<ConfiguredDocumentClass<typeof TokenDocument>>['data']['_source'],\n      userId: DocumentModificationOptions\n    ): void;\n\n    /** @override */\n    protected _onUpdate(\n      data?: DeepPartial<InstanceType<ConfiguredDocumentClass<typeof TokenDocument>>['data']['_source']>,\n      options?: DocumentModificationOptions & { animate?: boolean },\n      userId?: string\n    ): void;\n\n    /** @override */\n    protected _onDelete(options?: DocumentModificationOptions, userId?: string): void;\n\n    /** @override */\n    protected _canControl(\n      user?: InstanceType<ConfiguredDocumentClass<typeof User>>,\n      event?: PIXI.InteractionEvent\n    ): boolean;\n\n    /** @override */\n    protected _canHUD(user: InstanceType<ConfiguredDocumentClass<typeof User>>, event?: PIXI.InteractionEvent): boolean;\n\n    /** @override */\n    protected _canConfigure(\n      user?: InstanceType<ConfiguredDocumentClass<typeof User>>,\n      event?: PIXI.InteractionEvent\n    ): true;\n\n    /** @override */\n    protected _canHover(user?: InstanceType<ConfiguredDocumentClass<typeof User>>, event?: PIXI.InteractionEvent): true;\n\n    /** @override */\n    protected _canView(\n      user?: InstanceType<ConfiguredDocumentClass<typeof User>>,\n      event?: PIXI.InteractionEvent\n    ): boolean;\n\n    /** @override */\n    protected _canDrag(user: InstanceType<ConfiguredDocumentClass<typeof User>>, event: PIXI.InteractionEvent): boolean;\n\n    /** @override */\n    protected _onHoverIn(event: PIXI.InteractionEvent, options?: { hoverOutOthers?: boolean }): void;\n\n    /** @override */\n    protected _onHoverOut(event: PIXI.InteractionEvent): false | void;\n\n    /** @override */\n    protected _onClickLeft(event: PIXI.InteractionEvent): void;\n\n    /** @override */\n    protected _onClickLeft2(event?: PIXI.InteractionEvent): void;\n\n    /** @override */\n    protected _onClickRight2(event: PIXI.InteractionEvent): void;\n\n    /** @override */\n    protected _onDragLeftDrop(event: PIXI.InteractionEvent): Promise<any>;\n\n    /** @override */\n    protected _onDragLeftMove(event: PIXI.InteractionEvent): void;\n\n    /**\n     * @deprecated since 0.8.0\n     */\n    static fromActor(\n      actor: InstanceType<ConfiguredDocumentClass<typeof Actor>>,\n      tokenData?: InstanceType<ConfiguredDocumentClass<typeof TokenDocument>>['data']['_source']\n    ): never;\n\n    /**\n     * @deprecated since 0.8.0\n     */\n    getBarAttribute(\n      barName: string,\n      { alternative }?: { alternative?: string }\n    ): ReturnType<this['document']['getBarAttribute']>;\n\n    /**\n     * @remarks This does not exist in foundry. It marks the controlIcon as not used because `Token` does never store a value here.\n     */\n    controlIcon: null;\n  }\n\n  namespace Token {\n    interface Bar {\n      attribute: string;\n    }\n\n    interface Velocity {\n      dx: number;\n      sx: number;\n      dy: number;\n      sy: number;\n    }\n  }\n}\n\ninterface PositionOptions {\n  /**\n   * Animate the movement path\n   * @defaultValue `true`\n   */\n  animate?: boolean;\n}\n\ninterface EffectToggleOptions {\n  /**\n   * Force a certain active state for the effect\n   * @defaultValue `false`\n   */\n  active?: boolean;\n\n  /**\n   * Whether to set the effect as the overlay effect?\n   * @defaultValue `false`\n   */\n  overlay?: boolean;\n}\n"
    ]
  