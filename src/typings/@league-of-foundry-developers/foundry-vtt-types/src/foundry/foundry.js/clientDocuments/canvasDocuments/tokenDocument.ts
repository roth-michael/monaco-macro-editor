
    export default [
      "@league-of-foundry-developers/foundry-vtt-types/src/foundry/foundry.js/clientDocuments/canvasDocuments/tokenDocument.d.ts",
      "import { ConfiguredDocumentClass } from '../../../../types/helperTypes';\nimport { DocumentModificationOptions } from '../../../common/abstract/document.mjs';\nimport * as data from '../../../common/data/data.mjs';\n\ndeclare global {\n  /**\n   * The client-side Token document which extends the common BaseToken model.\n   * Each Token document contains TokenData which defines its data schema.\n   *\n   * @see {@link data.TokenData}                The Token data schema\n   * @see {@link documents.Scene}               The Scene document type which contains Token embedded documents\n   * @see {@link applications.TokenConfig}      The Token configuration application\n   */\n  class TokenDocument extends CanvasDocumentMixin(foundry.documents.BaseToken) {\n    /**\n     * @param data    - Initial data provided to construct the Token document\n     *                  (default: `{}`)\n     * @param context - The parent Scene document to which this Token belongs\n     */\n    constructor(\n      data?: ConstructorParameters<ConstructorOf<foundry.documents.BaseToken>>[0],\n      context?: ConstructorParameters<ConstructorOf<foundry.documents.BaseToken>>[1]\n    );\n\n    /**\n     * A cached reference to the Actor document that this Token modifies.\n     * This may be a \"synthetic\" unlinked Token Actor which does not exist in the World.\n     */\n    protected _actor: InstanceType<ConfiguredDocumentClass<typeof Actor>> | null;\n\n    /**\n     * A lazily evaluated reference to the Actor this Token modifies.\n     * If actorLink is true, then the entity is the primary Actor document.\n     * Otherwise the Actor entity is a synthetic (ephemeral) document constructed using the Token's actorData.\n     */\n    get actor(): InstanceType<ConfiguredDocumentClass<typeof Actor>> | null;\n\n    /**\n     * An indicator for whether or not the current User has full control over this Token document.\n     */\n    get isOwner(): boolean;\n\n    /**\n     * A convenient reference for whether this TokenDocument is linked to the Actor it represents, or is a synthetic copy\n     */\n    get isLinked(): boolean;\n\n    /**\n     * Return a reference to a Combatant that represents this Token, if one is present in the current encounter.\n     */\n    get combatant(): InstanceType<ConfiguredDocumentClass<typeof Combatant>> | null;\n\n    /**\n     * An indicator for whether or not this Token is currently involved in the active combat encounter.\n     */\n    get inCombat(): boolean;\n\n    /**\n     * @param data    - (default: `{}`, unused)\n     * @param options - (default: `{}`, unused)\n     * @override\n     */\n    clone(\n      data?: Parameters<foundry.documents.BaseToken['clone']>[0],\n      options?: Parameters<foundry.documents.BaseToken['clone']>[1]\n    ): TemporaryDocument<this>;\n\n    /**\n     * Create a synthetic Actor using a provided Token instance\n     * If the Token data is linked, return the true Actor entity\n     * If the Token data is not linked, create a synthetic Actor using the Token's actorData override\n     */\n    getActor(): InstanceType<ConfiguredDocumentClass<typeof Actor>> | null;\n\n    /**\n     * A helper method to retrieve the underlying data behind one of the Token's attribute bars\n     * @param barName     - The named bar to retrieve the attribute for\n     * @param alternative - An alternative attribute path to get instead of the default one\n     * @returns The attribute displayed on the Token bar, if any\n     */\n    getBarAttribute(\n      barName: string,\n      { alternative }?: { alternative?: string }\n    ): SingleAttributeBar | ObjectAttributeBar | null;\n\n    /**\n     * Redirect updates to a synthetic Token Actor to instead update the tokenData override object.\n     * Once an attribute in the Token has been overridden, it must always remain overridden.\n     *\n     * @param update  - The provided differential update data which should update the Token Actor\n     * @param options - Provided options which modify the update request\n     * @returns The updated un-linked Actor instance\n     */\n    modifyActorDocument(\n      update: Parameters<InstanceType<ConfiguredDocumentClass<typeof Actor>>['update']>[0],\n      options: Parameters<this['update']>[1]\n    ): Promise<[this['actor']]>;\n\n    /** @override */\n    getEmbeddedCollection(embeddedName: 'Item'): data.ActorData['items'];\n    getEmbeddedCollection(embeddedName: 'ActiveEffect'): data.ActorData['effects'];\n\n    /**\n     * Redirect creation of Documents within a synthetic Token Actor to instead update the tokenData override object.\n     * @param embeddedName - The named embedded Document type being modified\n     * @param data         - The provided initial data with which to create the embedded Documents\n     * @param options      - Provided options which modify the creation request\n     * @returns The created Embedded Document instances\n     */\n    createActorEmbeddedDocuments(\n      embeddedName: 'Item',\n      data: Array<ConstructorParameters<ConfiguredDocumentClass<typeof Item>>[0] | Record<string, unknown>>,\n      options: Parameters<this['update']>[1]\n    ): Promise<InstanceType<ConfiguredDocumentClass<typeof Item>>[]>;\n    createActorEmbeddedDocuments(\n      embeddedName: 'ActiveEffect',\n      data: Array<ConstructorParameters<ConfiguredDocumentClass<typeof ActiveEffect>>[0] | Record<string, unknown>>,\n      options: Parameters<this['update']>[1]\n    ): Promise<InstanceType<ConfiguredDocumentClass<typeof ActiveEffect>>[]>;\n\n    /**\n     * Redirect updating of Documents within a synthetic Token Actor to instead update the tokenData override object.\n     * @param embeddedName - The named embedded Document type being modified\n     * @param updates      - The provided differential data with which to update the embedded Documents\n     * @param options      - Provided options which modify the update request\n     * @returns The updated Embedded Document instances\n     */\n    updateActorEmbeddedDocuments(\n      embeddedName: 'Item',\n      updates: Array<ConstructorParameters<ConfiguredDocumentClass<typeof Item>>[0] | Record<string, unknown>>,\n      options: Parameters<this['update']>[1]\n    ): Promise<InstanceType<ConfiguredDocumentClass<typeof Item>>[]>;\n    updateActorEmbeddedDocuments(\n      embeddedName: 'ActiveEffect',\n      updates: Array<ConstructorParameters<ConfiguredDocumentClass<typeof ActiveEffect>>[0] | Record<string, unknown>>,\n      options: Parameters<this['update']>[1]\n    ): Promise<InstanceType<ConfiguredDocumentClass<typeof ActiveEffect>>[]>;\n\n    /**\n     * Redirect deletion of Documents within a synthetic Token Actor to instead update the tokenData override object.\n     * @param embeddedName - The named embedded Document type being modified\n     * @param ids          - The provided differential data with which to update the embedded Documents\n     * @param options      - Provided options which modify the update request\n     * @returns The updated Embedded Document instances\n     */\n    deleteActorEmbeddedDocuments(\n      embeddedName: 'Item',\n      ids: string[],\n      options: Parameters<this['update']>[1]\n    ): Promise<InstanceType<ConfiguredDocumentClass<typeof Item>>[]>;\n    deleteActorEmbeddedDocuments(\n      embeddedName: 'ActiveEffect',\n      ids: string[],\n      options: Parameters<this['update']>[1]\n    ): Promise<InstanceType<ConfiguredDocumentClass<typeof ActiveEffect>>[]>;\n\n    /** @override */\n    protected _preUpdate(\n      data: Parameters<foundry.documents.BaseToken['_preUpdate']>[0],\n      options: DocumentModificationOptions,\n      user: InstanceType<ConfiguredDocumentClass<typeof User>>\n    ): Promise<void>;\n\n    /**\n     * When the Actor data overrides change for an un-linked Token Actor, simulate the pre-update process.\n     */\n    protected _preUpdateTokenActor(\n      data: Parameters<foundry.documents.BaseActor['_preUpdate']>[0],\n      options: DocumentModificationOptions,\n      user: InstanceType<ConfiguredDocumentClass<typeof User>>\n    ): Promise<void>;\n\n    /** @override */\n    protected _onUpdate(\n      data: Parameters<foundry.documents.BaseToken['_onUpdate']>[0],\n      options: DocumentModificationOptions,\n      userId: string\n    ): void;\n\n    /**\n     * When the base Actor for a TokenDocument changes, we may need to update its Actor instance\n     * @param update - (default: `{}`)\n     */\n    protected _onUpdateBaseActor(update?: Parameters<foundry.documents.BaseActor['_onUpdate']>[0]): void;\n\n    /**\n     * When the Actor data overrides change for an un-linked Token Actor, simulate the post-update process.\n     */\n    protected _onUpdateTokenActor(\n      data: Parameters<foundry.documents.BaseActor['_onUpdate']>[0],\n      options: DocumentModificationOptions,\n      userId: string\n    ): void;\n\n    /**\n     * Get an Array of attribute choices which could be tracked for Actors in the Combat Tracker\n     * @param _path - (default: `[]`)\n     */\n    static getTrackedAttributes(\n      data?: InstanceType<ConfiguredDocumentClass<typeof Actor>>['data']['data'],\n      _path?: string[]\n    ): TrackedAttributes;\n\n    /**\n     * Inspect the Actor data model and identify the set of attributes which could be used for a Token Bar\n     */\n    static getTrackedAttributeChoices(attributes?: TrackedAttributes): Partial<Record<string, string[]>>;\n  }\n}\n\ninterface SingleAttributeBar {\n  type: 'value';\n  attribute: string;\n  value: number;\n  editable: boolean;\n}\n\ninterface ObjectAttributeBar {\n  type: 'bar';\n  attribute: string;\n  value: number;\n  max: number;\n  editable: boolean;\n}\n\ninterface TrackedAttributes {\n  bar: string[][];\n  value: string[][];\n}\n\nexport {};\n"
    ]
  