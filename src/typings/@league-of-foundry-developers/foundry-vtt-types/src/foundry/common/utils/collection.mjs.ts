
    export default [
      "@league-of-foundry-developers/foundry-vtt-types/src/foundry/common/utils/collection.mjs.d.ts",
      "interface MapReplacementMembers<K, V> {\n  set(key: K, value: V): this;\n}\n\ntype PatchedMap<K, V> = Omit<Map<K, V>, 'forEach' | typeof Symbol.iterator | 'get' | 'set'> &\n  MapReplacementMembers<K, V>;\n\ninterface PatchedMapConstructor {\n  new (): PatchedMap<any, any>;\n  new <K, V>(entries?: readonly (readonly [K, V])[] | null): PatchedMap<K, V>;\n  new <K, V>(iterable: Iterable<readonly [K, V]>): PatchedMap<K, V>;\n  readonly [Symbol.species]: PatchedMapConstructor;\n  readonly prototype: PatchedMap<any, any>;\n}\n\ndeclare const Map: PatchedMapConstructor;\n\n/**\n * A reusable storage concept which blends the functionality of an Array with the efficient key-based lookup of a Map.\n * This concept is reused throughout Foundry VTT where a collection of uniquely identified elements is required.\n * @typeParam T - The type of the objects contained in the Collection\n */\ndeclare class Collection<T> extends Map<string, T> {\n  constructor(entries?: readonly (readonly [string, T])[] | null);\n\n  /**\n   * When iterating over a Collection, we should iterate over its values instead of over its entries\n   */\n  [Symbol.iterator](): IterableIterator<T>;\n\n  /**\n   * Return an Array of all the entry values in the Collection\n   */\n  get contents(): T[];\n\n  /**\n   * Find an entry in the Map using an functional condition.\n   * @see {@link Array#find}\n   *\n   * @param condition - The functional condition to test\n   * @returns The value, if found, otherwise undefined\n   *\n   * @example\n   * ```typescript\n   * let c = new Collection([[\"a\", \"A\"], [\"b\", \"B\"], [\"c\", \"C\"]]);\n   * let a = c.find(entry => entry === \"A\");\n   * ```\n   */\n  find<S extends T>(condition: (e: T) => e is S): S | undefined;\n  find(condition: (e: T) => boolean): T | undefined;\n\n  /**\n   * Filter the Collection, returning an Array of entries which match a functional condition.\n   * @see {@link Array#filter}\n   *\n   * @param condition - The functional condition to test\n   * @returns An Array of matched values\n   *\n   * @example\n   * ```typescript\n   * let c = new Collection([[\"a\", \"AA\"], [\"b\", \"AB\"], [\"c\", \"CC\"]]);\n   * let hasA = c.filters(entry => entry.slice(0) === \"A\");\n   * ```\n   */\n  filter<S extends T>(condition: (e: T) => e is S): S[];\n  filter(condition: (e: T) => boolean): T[];\n\n  /**\n   * Apply a function to each element of the collection\n   * @see Array#forEach\n   * @param fn - The function to apply\n   *\n   * @example\n   * ```typescript\n   * let c = new Collection([[\"a\", {active: false}], [\"b\", {active: false}], [\"c\", {active: false}]]);\n   * c.forEach(e => e.active = true);\n   * ```\n   */\n  forEach(fn: (e: T) => void): void;\n\n  /**\n   * Get an element from the Collection by its key.\n   * @param key     - The key of the entry to retrieve\n   * @param strict  - Throw an Error if the requested id does not exist, otherwise\n   *                  (default: `false`)\n   * @returns The retrieved entry value, if the key exists, otherwise undefined\n   * @example\n   * ```typescript\n   * let c = new Collection([[\"a\", \"A\"], [\"b\", \"B\"], [\"c\", \"C\"]]);\n   * c.get(\"a\"); // \"A\"\n   * c.get(\"d\"); // null\n   * c.get(\"d\", {strict: true}); // throws Error\n   * ```\n   */\n  get(key: string, { strict }: { strict: true }): T;\n  get(key: string, { strict }?: { strict?: false }): T | undefined;\n\n  /**\n   * Get an entry from the Collection by name.\n   * Use of this method assumes that the objects stored in the collection have a \"name\" attribute.\n   * @param name    - The name of the entry to retrieve\n   * @param strict  - Throw an Error if the requested id does not exist,\n   *                  otherwise return null.\n   *                  (default: `false`)\n   * @returns The retrieved Entity, if one was found, otherwise undefined\n   */\n  getName(name: string, { strict }: { strict: true }): T;\n  getName(name: string, { strict }?: { strict?: false }): T | undefined;\n\n  /**\n   * Transform each element of the Collection into a new form, returning an Array of transformed values\n   * @param transformer - The transformation function to apply to each entry value\n   * @typeParam M       - The type of the mapped values\n   * @returns An Array of transformed values\n   */\n  map<M>(transformer: (entity: T) => M): M[];\n\n  /**\n   * Reduce the Collection by applying an evaluator function and accumulating entries\n   * @see {@link Array#reduce}\n   * @param evaluator - A function which mutates the accumulator each iteration\n   * @param initial   - An initial value which accumulates with each iteration\n   * @typeParam A     - The type of the accumulator and the return value\n   * @returns The accumulated result\n   *\n   * @example\n   * ```typescript\n   * let c = new Collection([[\"a\", \"A\"], [\"b\", \"B\"], [\"c\", \"C\"]]);\n   * let letters = c.reduce((s, l) => {\n   *   return s + l;\n   * }, \"\"); // \"ABC\"\n   * ```\n   */\n  reduce<A>(evaluator: (accumulator: A, entity: T) => A, initial: A): A;\n\n  /**\n   * Test whether a condition is met by some entry in the Collection\n   * @see Array#some\n   * @param condition - A test condition to apply to each entry\n   * @returns Was the test condition passed by at least one entry?\n   */\n  some(condition: (e: T) => boolean): boolean;\n\n  /**\n   * Convert the Collection to a primitive array of its contents.\n   * @returns An array of contained values\n   */\n  toJSON(): Array<T extends { toJSON: (...args: any[]) => infer U } ? U : T>;\n}\n\nexport default Collection;\n"
    ]
  