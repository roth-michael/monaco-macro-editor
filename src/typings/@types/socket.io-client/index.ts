
    export default [
      "@types/socket.io-client/index.d.ts",
      "// Type definitions for socket.io-client 1.4.5\n// Project: http://socket.io/\n// Definitions by: PROGRE <https://github.com/progre>, Damian Connolly <https://github.com/divillysausages>, Florent Poujol <https://github.com/florentpoujol>\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\n\ndeclare var io: SocketIOClientStatic;\n\ndeclare module 'socket.io-client' {\n    export = io;\n}\n\ninterface SocketIOClientStatic {\n\n    /**\n     * Looks up an existing 'Manager' for multiplexing. If the user summons:\n     *     'io( 'http://localhost/a' );'\n     *     'io( 'http://localhost/b' );'\n     *\n     * We reuse the existing instance based on the same scheme/port/host, and\n     * we initialize sockets for each namespace. If autoConnect isn't set to\n     * false in the options, then we'll automatically connect\n     * @param uri The uri that we'll connect to, including the namespace, where '/' is the default one (e.g. http://localhost:4000/somenamespace)\n     * @opts Any connect options that we want to pass along\n     * @return A Socket object\n     */\n    ( uri: string, opts?: SocketIOClient.ConnectOpts ): SocketIOClient.Socket;\n\n    /**\n     * Auto-connects to the window location and defalt namespace.\n     * E.g. window.protocol + '//' + window.host + ':80/'\n     * @opts Any connect options that we want to pass along\n     * @return A Socket object\n     */\n    ( opts?: SocketIOClient.ConnectOpts ): SocketIOClient.Socket;\n\n    /**\n     * @see the default constructor (io(uri, opts))\n     */\n    connect( uri: string, opts?: SocketIOClient.ConnectOpts ): SocketIOClient.Socket;\n\n    /**\n     * @see the default constructor (io(opts))\n     */\n    connect( opts?: SocketIOClient.ConnectOpts ): SocketIOClient.Socket;\n\n    /**\n     * The socket.io protocol revision number this client works with\n     * @default 4\n     */\n    protocol: number;\n\n    /**\n     * Socket constructor - exposed for the standalone build\n     */\n    Socket: SocketIOClient.Socket;\n\n    /**\n     * Manager constructor - exposed for the standalone build\n     */\n    Manager: SocketIOClient.ManagerStatic;\n\n    /**\n     * Managers cache\n     */\n    managers: { [key: string]: SocketIOClient.Manager }\n}\n\ndeclare namespace SocketIOClient {\n\n    /**\n     * The base emiter class, used by Socket and Manager\n     */\n    interface Emitter {\n        /**\n         * Adds a listener for a particular event. Calling multiple times will add\n         * multiple listeners\n         * @param event The event that we're listening for\n         * @param fn The function to call when we get the event. Parameters depend on the\n         * event in question\n         * @return This Emitter\n         */\n        on( event: string, fn: Function ):Emitter;\n\n        /**\n         * @see on( event, fn )\n         */\n        addEventListener( event: string, fn: Function ):Emitter;\n\n        /**\n         * Adds a listener for a particular event that will be invoked\n         * a single time before being automatically removed\n         * @param event The event that we're listening for\n         * @param fn The function to call when we get the event. Parameters depend on\n         * the event in question\n         * @return This Emitter\n         */\n        once( event: string, fn: Function ):Emitter;\n\n        /**\n         * Removes a listener for a particular type of event. This will either\n         * remove a specific listener, or all listeners for this type of event\n         * @param event The event that we want to remove the listener of\n         * @param fn The function to remove, or null if we want to remove all functions\n         * @return This Emitter\n         */\n        off( event: string, fn?: Function ):Emitter;\n\n        /**\n         * @see off( event, fn )\n         */\n        removeListener( event: string, fn?: Function ):Emitter;\n\n        /**\n         * @see off( event, fn )\n         */\n        removeEventListener( event: string, fn?: Function ):Emitter;\n\n        /**\n         * Removes all event listeners on this object\n         * @return This Emitter\n         */\n        removeAllListeners():Emitter;\n\n        /**\n         * Emits 'event' with the given args\n         * @param event The event that we want to emit\n         * @param args Optional arguments to emit with the event\n         * @return Emitter\n         */\n        emit( event: string, ...args: any[] ):Emitter;\n\n        /**\n         * Returns all the callbacks for a particular event\n         * @param event The event that we're looking for the callbacks of\n         * @return An array of callback Functions, or an empty array if we don't have any\n         */\n        listeners( event: string ):Function[];\n\n        /**\n         * Returns if we have listeners for a particular event\n         * @param event The event that we want to check if we've listeners for\n         * @return True if we have listeners for this event, false otherwise\n         */\n        hasListeners( event: string ):boolean;\n    }\n\n    /**\n     * The Socket static interface\n     */\n    interface SocketStatic {\n\n        /**\n         * Creates a new Socket, used for communicating with a specific namespace\n         * @param io The Manager that's controlling this socket\n         * @param nsp The namespace that this socket is for (@default '/')\n         * @return A new Socket\n         */\n        ( io: SocketIOClient.Manager, nsp: string ): Socket;\n\n        /**\n         * Creates a new Socket, used for communicating with a specific namespace\n         * @param io The Manager that's controlling this socket\n         * @param nsp The namespace that this socket is for (@default '/')\n         * @return A new Socket\n         */\n        new ( url: string, opts: any ): SocketIOClient.Manager;\n    }\n\n    /**\n     * The Socket that we use to connect to a Namespace on the server\n     */\n    interface Socket extends Emitter {\n\n        /**\n         * The Manager that's controller this socket\n         */\n        io: SocketIOClient.Manager;\n\n        /**\n         * The namespace that this socket is for\n         * @default '/'\n         */\n        nsp: string;\n\n        /**\n         * The ID of the socket; matches the server ID and is set when we're connected, and cleared\n         * when we're disconnected\n         */\n        id: string;\n\n        /**\n         * Are we currently connected?\n         * @default false\n         */\n        connected: boolean;\n\n        /**\n         * Are we currently disconnected?\n         * @default true\n         */\n        disconnected: boolean;\n\n        /**\n         * The type of binary data being transmitted by the connection.\n         * https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/binaryType\n         */\n        binaryType: \"blob\" | \"arraybuffer\";\n\n        /**\n         * Opens our socket so that it connects. If the 'autoConnect' option for io is\n         * true (default), then this is called automatically when the Socket is created\n         */\n        open(): Socket;\n\n        /**\n         * @see open();\n         */\n        connect(): Socket;\n\n        /**\n         * Sends a 'message' event\n         * @param args Any optional arguments that we want to send\n         * @see emit\n         * @return This Socket\n         */\n        send( ...args: any[] ):Socket;\n\n        /**\n         * An override of the base emit. If the event is one of:\n         *     connect\n         *     connect_error\n         *     connect_timeout\n         *     connecting\n         *     disconnect\n         *     error\n         *     reconnect\n         *     reconnect_attempt\n         *     reconnect_failed\n         *     reconnect_error\n         *     reconnecting\n         *     ping\n         *     pong\n         * then the event is emitted normally. Otherwise, if we're connected, the\n         * event is sent. Otherwise, it's buffered.\n         *\n         * If the last argument is a function, then it will be called\n         * as an 'ack' when the response is received. The parameter(s) of the\n         * ack will be whatever data is returned from the event\n         * @param event The event that we're emitting\n         * @param args Optional arguments to send with the event\n         * @return This Socket\n         */\n        emit( event: string, ...args: any[] ):Socket;\n\n        /**\n         * Disconnects the socket manually\n         * @return This Socket\n         */\n        close():Socket;\n\n        /**\n         * @see close()\n         */\n        disconnect():Socket;\n\n        /**\n        * Sets the compress flag.\n        * @param compress If `true`, compresses the sending data\n        * @return this Socket\n        */\n        compress(compress: boolean):Socket;\n    }\n\n    /**\n     * The Manager static interface\n     */\n    interface ManagerStatic {\n        /**\n         * Creates a new Manager\n         * @param uri The URI that we're connecting to (e.g. http://localhost:4000)\n         * @param opts Any connection options that we want to use (and pass to engine.io)\n         * @return A Manager\n         */\n        ( uri: string, opts?: SocketIOClient.ConnectOpts ): SocketIOClient.Manager;\n\n        /**\n         * Creates a new Manager with the default URI (window host)\n         * @param opts Any connection options that we want to use (and pass to engine.io)\n         */\n        ( opts: SocketIOClient.ConnectOpts ):SocketIOClient.Manager;\n\n        /**\n         * @see default constructor\n         */\n        new ( uri: string, opts?: SocketIOClient.ConnectOpts ): SocketIOClient.Manager;\n\n        /**\n         * @see default constructor\n         */\n        new ( opts: SocketIOClient.ConnectOpts ):SocketIOClient.Manager;\n    }\n\n    /**\n     * The Manager class handles all the Namespaces and Sockets that we're using\n     */\n    interface Manager extends Emitter {\n\n        /**\n         * All the namespaces currently controlled by this Manager, and the Sockets\n         * that we're using to communicate with them\n         */\n        nsps: { [namespace:string]: Socket };\n\n        /**\n         * The connect options that we used when creating this Manager\n         */\n        opts: SocketIOClient.ConnectOpts;\n\n        /**\n         * The state of the Manager. Either 'closed', 'opening', or 'open'\n         */\n        readyState: string;\n\n        /**\n         * The URI that this manager is for (host + port), e.g. 'http://localhost:4000'\n         */\n        uri: string;\n\n        /**\n         * The currently connected sockets\n         */\n        connecting: Socket[];\n\n        /**\n         * If we should auto connect (also used when creating Sockets). Set via the\n         * opts object\n         */\n        autoConnect: boolean;\n\n        /**\n         * Gets if we should reconnect automatically\n         * @default true\n         */\n        reconnection(): boolean;\n\n        /**\n         * Sets if we should reconnect automatically\n         * @param v True if we should reconnect automatically, false otherwise\n         * @default true\n         * @return This Manager\n         */\n        reconnection( v: boolean ): Manager;\n\n        /**\n         * Gets the number of reconnection attempts we should try before giving up\n         * @default Infinity\n         */\n        reconnectionAttempts(): number;\n\n        /**\n         * Sets the number of reconnection attempts we should try before giving up\n         * @param v The number of attempts we should do before giving up\n         * @default Infinity\n         * @return This Manager\n         */\n        reconnectionAttempts( v: number ): Manager;\n\n        /**\n         * Gets the delay in milliseconds between each reconnection attempt\n         * @default 1000\n         */\n        reconnectionDelay(): number;\n\n        /**\n         * Sets the delay in milliseconds between each reconnection attempt\n         * @param v The delay in milliseconds\n         * @default 1000\n         * @return This Manager\n         */\n        reconnectionDelay( v: number ): Manager;\n\n        /**\n         * Gets the max reconnection delay in milliseconds between each reconnection\n         * attempt\n         * @default 5000\n         */\n        reconnectionDelayMax(): number;\n\n        /**\n         * Sets the max reconnection delay in milliseconds between each reconnection\n         * attempt\n         * @param v The max reconnection dleay in milliseconds\n         * @return This Manager\n         */\n        reconnectionDelayMax( v: number ): Manager;\n\n        /**\n         * Gets the randomisation factor used in the exponential backoff jitter\n         * when reconnecting\n         * @default 0.5\n         */\n        randomizationFactor(): number;\n\n        /**\n         * Sets the randomisation factor used in the exponential backoff jitter\n         * when reconnecting\n         * @param The reconnection randomisation factor\n         * @default 0.5\n         * @return This Manager\n         */\n        randomizationFactor( v: number ): Manager;\n\n        /**\n         * Gets the timeout in milliseconds for our connection attempts\n         * @default 20000\n         */\n        timeout(): number;\n\n        /**\n         * Sets the timeout in milliseconds for our connection attempts\n         * @param The connection timeout milliseconds\n         * @return This Manager\n         */\n        timeout(v: number): Manager;\n\n        /**\n         * Sets the current transport socket and opens our connection\n         * @param fn An optional callback to call when our socket has either opened, or\n         * failed. It can take one optional parameter of type Error\n         * @return This Manager\n         */\n        open( fn?: (err?: any) => void ): Manager;\n\n        /**\n         * @see open( fn );\n         */\n        connect( fn?: (err?: any) => void ): Manager;\n\n        /**\n         * Creates a new Socket for the given namespace\n         * @param nsp The namespace that this Socket is for\n         * @return A new Socket, or if one has already been created for this namespace,\n         * an existing one\n         */\n        socket( nsp: string ): Socket;\n    }\n\n    /**\n     * Options we can pass to the socket when connecting\n     */\n    interface ConnectOpts {\n\n        /**\n         * Should we force a new Manager for this connection?\n         * @default false\n         */\n        forceNew?: boolean;\n\n        /**\n         * Should we multiplex our connection (reuse existing Manager) ?\n         * @default true\n         */\n        multiplex?: boolean;\n\n        /**\n         * The path to get our client file from, in the case of the server\n         * serving it\n         * @default '/socket.io'\n         */\n        path?: string;\n\n        /**\n         * Should we allow reconnections?\n         * @default true\n         */\n        reconnection?: boolean;\n\n        /**\n         * How many reconnection attempts should we try?\n         * @default Infinity\n         */\n        reconnectionAttempts?: number;\n\n        /**\n         * The time delay in milliseconds between reconnection attempts\n         * @default 1000\n         */\n        reconnectionDelay?: number;\n\n        /**\n         * The max time delay in milliseconds between reconnection attempts\n         * @default 5000\n         */\n        reconnectionDelayMax?: number;\n\n        /**\n         * Used in the exponential backoff jitter when reconnecting\n         * @default 0.5\n         */\n        randomizationFactor?: number;\n\n        /**\n         * The timeout in milliseconds for our connection attempt\n         * @default 20000\n         */\n        timeout?: number;\n\n        /**\n         * Should we automically connect?\n         * @default true\n         */\n        autoConnect?: boolean;\n\n        /**\n         * The host that we're connecting to. Set from the URI passed when connecting\n         */\n        host?: string;\n\n        /**\n         * The hostname for our connection. Set from the URI passed when connecting\n         */\n        hostname?: string;\n\n        /**\n         * If this is a secure connection. Set from the URI passed when connecting\n         */\n        secure?: boolean;\n\n        /**\n         * The port for our connection. Set from the URI passed when connecting\n         */\n        port?: string;\n\n        /**\n         * Any query parameters in our uri. Set from the URI passed when connecting\n         */\n        query?: Object;\n\n        /**\n         * `http.Agent` to use, defaults to `false` (NodeJS only)\n         */\n        agent?: string|boolean;\n\n        /**\n         * Whether the client should try to upgrade the transport from\n         * long-polling to something better.\n         * @default true\n         */\n        upgrade?: boolean;\n\n        /**\n         * Forces JSONP for polling transport.\n         */\n        forceJSONP?: boolean;\n\n        /**\n         * Determines whether to use JSONP when necessary for polling. If\n         * disabled (by settings to false) an error will be emitted (saying\n         * \"No transports available\") if no other transports are available.\n         * If another transport is available for opening a connection (e.g.\n         * WebSocket) that transport will be used instead.\n         * @default true\n         */\n        jsonp?: boolean;\n\n        /**\n         * Forces base 64 encoding for polling transport even when XHR2\n         * responseType is available and WebSocket even if the used standard\n         * supports binary.\n         */\n        forceBase64?: boolean;\n\n        /**\n         * Enables XDomainRequest for IE8 to avoid loading bar flashing with\n         * click sound. default to `false` because XDomainRequest has a flaw\n         * of not sending cookie.\n         * @default false\n         */\n        enablesXDR?: boolean;\n\n        /**\n         * The param name to use as our timestamp key\n         * @default 't'\n         */\n        timestampParam?: string;\n\n        /**\n         * Whether to add the timestamp with each transport request. Note: this\n         * is ignored if the browser is IE or Android, in which case requests\n         * are always stamped\n         * @default false\n         */\n        timestampRequests?: boolean;\n\n        /**\n         * A list of transports to try (in order). Engine.io always attempts to\n         * connect directly with the first one, provided the feature detection test\n         * for it passes.\n         * @default ['polling','websocket']\n         */\n        transports?: string[];\n\n        /**\n         * The port the policy server listens on\n         * @default 843\n         */\n        policyPost?: number;\n\n        /**\n         * If true and if the previous websocket connection to the server succeeded,\n         * the connection attempt will bypass the normal upgrade process and will\n         * initially try websocket. A connection attempt following a transport error\n         * will use the normal upgrade process. It is recommended you turn this on\n         * only when using SSL/TLS connections, or if you know that your network does\n         * not block websockets.\n         * @default false\n         */\n        rememberUpgrade?: boolean;\n\n        /**\n         * Are we only interested in transports that support binary?\n         */\n        onlyBinaryUpgrades?: boolean;\n\n        /**\n         * Transport options for Node.js client (headers etc)\n         */\n        transportOptions?: Object;\n\n        /**\n         * (SSL) Certificate, Private key and CA certificates to use for SSL.\n         * Can be used in Node.js client environment to manually specify\n         * certificate information.\n         */\n        pfx?: string;\n\n        /**\n         * (SSL) Private key to use for SSL. Can be used in Node.js client\n         * environment to manually specify certificate information.\n         */\n        key?: string;\n\n        /**\n         * (SSL) A string or passphrase for the private key or pfx. Can be\n         * used in Node.js client environment to manually specify certificate\n         * information.\n         */\n        passphrase?: string\n\n        /**\n         * (SSL) Public x509 certificate to use. Can be used in Node.js client\n         * environment to manually specify certificate information.\n         */\n        cert?: string;\n\n        /**\n         * (SSL) An authority certificate or array of authority certificates to\n         * check the remote host against.. Can be used in Node.js client\n         * environment to manually specify certificate information.\n         */\n        ca?: string|string[];\n\n        /**\n         * (SSL) A string describing the ciphers to use or exclude. Consult the\n         * [cipher format list]\n         * (http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT) for\n         * details on the format.. Can be used in Node.js client environment to\n         * manually specify certificate information.\n         */\n        ciphers?: string;\n\n        /**\n         * (SSL) If true, the server certificate is verified against the list of\n         * supplied CAs. An 'error' event is emitted if verification fails.\n         * Verification happens at the connection level, before the HTTP request\n         * is sent. Can be used in Node.js client environment to manually specify\n         * certificate information.\n         */\n        rejectUnauthorized?: boolean;\n\n    }\n}\n"
    ]
  