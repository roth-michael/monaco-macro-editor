
    export default [
      "@league-of-foundry-developers/foundry-vtt-types/src/types/helperTypes.d.ts",
      "import DocumentData from '../foundry/common/abstract/data.mjs';\nimport { AnyDocumentData } from '../foundry/common/abstract/data.mjs';\nimport Document from '../foundry/common/abstract/document.mjs';\nimport EmbeddedCollection from '../foundry/common/abstract/embedded-collection.mjs';\n\nexport type PropertiesDataType<T extends Document<any, any> | AnyDocumentData> = T extends DocumentData<\n  any,\n  infer U,\n  any,\n  any\n>\n  ? U\n  : T extends Document<infer U, any>\n  ? PropertiesDataType<U>\n  : never;\n\ntype PropertyTypeToSourceType<T> = T extends EmbeddedCollection<infer U, any>\n  ? SourceDataType<InstanceType<U>>[]\n  : T extends Array<infer U>\n  ? Array<PropertyTypeToSourceType<U>>\n  : T extends AnyDocumentData\n  ? SourceDataType<T>\n  : T;\n\nexport type PropertiesToSource<T extends object> = {\n  [Key in keyof T]: PropertyTypeToSourceType<T[Key]>;\n};\n\ntype SourceDataType<T extends Document<any, any> | AnyDocumentData> = T extends DocumentData<\n  any,\n  any,\n  infer U,\n  any,\n  any\n>\n  ? U\n  : T extends Document<infer U, any>\n  ? SourceDataType<U>\n  : never;\n\n/**\n * Returns the type of the constructor data for the given {@link DocumentData}.\n */\nexport type ConstructorDataType<T extends AnyDocumentData> = T['_initializeSource'] extends (data: infer U) => any\n  ? U\n  : never;\n\ntype ObjectToDeepPartial<T> = T extends object ? DeepPartial<T> : T;\n\nexport type PropertyTypeToSourceParameterType<T> = ObjectToDeepPartial<PropertyTypeToSourceType<T>>;\n\n// TODO: Find a way to avoid this helper\nexport type FieldReturnType<T extends DocumentField<any>, U extends Partial<DocumentField<any>>> = Omit<T, keyof U> &\n  Exclude<U, 'undefined'>;\n\nexport type DocumentConstructor = Pick<typeof Document, keyof typeof Document> &\n  (new (...args: any[]) => Document<any, any>);\n\nexport type PlaceableObjectConstructor = Pick<typeof PlaceableObject, keyof typeof PlaceableObject> &\n  (new (...args: any[]) => PlaceableObject<any>);\n\nexport type ConfiguredDocumentClass<T extends DocumentConstructor> = ConfiguredDocumentClassForName<\n  T['metadata']['name']\n>;\n\nexport type DocumentType = keyof {\n  [Key in keyof CONFIG as 'documentClass' extends keyof CONFIG[Key] ? Key : never]: unknown;\n};\n\nexport type PlaceableDocumentType =\n  | 'AmbientLight'\n  | 'AmbientSound'\n  | 'Drawing'\n  | 'MeasuredTemplate'\n  | 'Note'\n  | 'Tile'\n  | 'Token'\n  | 'Wall';\n\nexport type ConfiguredDocumentClassForName<Name extends DocumentType> = 'documentClass' extends keyof CONFIG[Name]\n  ? CONFIG[Name]['documentClass']\n  : never;\n\nexport type ObjectType = keyof {\n  [Key in keyof CONFIG as 'objectClass' extends keyof CONFIG[Key] ? Key : never]: unknown;\n};\n\nexport type ConfiguredObjectClassForName<Name extends ObjectType> = 'objectClass' extends keyof CONFIG[Name]\n  ? CONFIG[Name]['objectClass']\n  : never;\n\nexport type ConfiguredData<Name extends string> = Name extends keyof DataConfig ? DataConfig[Name] : {};\n\nexport type ConfiguredSource<Name extends string> = Name extends keyof SourceConfig ? SourceConfig[Name] : {};\n\nexport type ConfiguredFlags<T extends string> = T extends keyof FlagConfig\n  ? FlagConfig[T] & Record<string, unknown>\n  : Record<string, unknown>;\n\nexport type ToObjectFalseType<T> = T extends {\n  toObject: (source: false) => infer U;\n}\n  ? U\n  : T;\n\nexport type ConfiguredSheetClass<T extends DocumentConstructor> = T['metadata']['name'] extends keyof CONFIG\n  ? 'sheetClass' extends keyof CONFIG[T['metadata']['name']]\n    ? CONFIG[T['metadata']['name']]['sheetClass']\n    : never\n  : T;\n\nexport type ObjectClass<T extends DocumentConstructor> = T['metadata']['name'] extends keyof CONFIG\n  ? 'objectClass' extends keyof CONFIG[T['metadata']['name']]\n    ? CONFIG[T['metadata']['name']]['objectClass']\n    : never\n  : T;\n\nexport type LayerClass<T extends DocumentConstructor> = T['metadata']['name'] extends keyof CONFIG\n  ? 'layerClass' extends keyof CONFIG[T['metadata']['name']]\n    ? CONFIG[T['metadata']['name']]['layerClass']\n    : never\n  : T;\n\nexport type DataSourceForPlaceable<P extends PlaceableObject> = P extends PlaceableObject<infer Doc>\n  ? Doc extends Document<infer D, any>\n    ? D['_source']\n    : never\n  : never;\n"
    ]
  