
    export default [
      "@league-of-foundry-developers/foundry-vtt-types/src/foundry/common/abstract/document.mjs.d.ts",
      "import { BaseUser } from '../documents.mjs';\nimport DatabaseBackend from './backend.mjs';\nimport { AnyDocumentData } from './data.mjs';\nimport {\n  ConfiguredDocumentClass,\n  DocumentConstructor,\n  ToObjectFalseType,\n  DocumentType,\n  ConstructorDataType\n} from '../../../types/helperTypes';\nimport EmbeddedCollection from './embedded-collection.mjs';\n\ntype ParentType<T extends Document<any, any>> = T extends Document<any, infer U> ? U : never;\nexport type ContextType<T extends Document<any, any>> = Context<ParentType<T>>;\nexport type DocumentDataType<T extends Document<any, any>> = T extends Document<infer U, any> ? U : never;\n\n/**\n * The abstract base class shared by both client and server-side which defines the model for a single document type.\n */\ndeclare abstract class Document<\n  ConcreteDocumentData extends AnyDocumentData,\n  Parent extends Document<any, any> | null = null\n> {\n  /**\n   * Create a new Document by providing an initial data object.\n   * @param data    - Initial data provided to construct the Document\n   * @param context - Additional parameters which define Document context\n   */\n  constructor(data?: ConstructorDataType<ConcreteDocumentData>, context?: Context<Parent>);\n\n  /**\n   * An immutable reverse-reference to the parent Document to which this embedded Document belongs.\n   */\n  readonly parent: Parent | null;\n\n  /**\n   * An immutable reference to a containing Compendium collection to which this Document belongs.\n   */\n  readonly pack: string | null;\n\n  /**\n   * The base data object for this Document which persists both the original source and any derived data.\n   */\n  readonly data: ConcreteDocumentData;\n\n  /**\n   * Perform one-time initialization tasks which only occur when the Document is first constructed.\n   */\n  protected _initialize(): void;\n\n  /**\n   * Every document must define an object which represents its data schema.\n   * This must be a subclass of the DocumentData interface.\n   *\n   * @remarks\n   * This method is abstract and needs to be implemented by inheriting classes.\n   */\n  static get schema(): ConstructorOf<AnyDocumentData>;\n\n  /**\n   * Default metadata which applies to each instance of this Document type.\n   * @defaultValue\n   * ```typescript\n   * {\n   *   name: \"Document\",\n   *   collection: \"documents\",\n   *   label: \"DOCUMENT.Document\",\n   *   types: [],\n   *   embedded: {},\n   *   hasSystemData: false,\n   *   permissions: {\n   *     create: \"ASSISTANT\",\n   *     update: \"ASSISTANT\",\n   *     delete: \"ASSISTANT\"\n   *   },\n   *   pack: null\n   * }\n   * ```\n   */\n  static get metadata(): Metadata<any>;\n\n  /**\n   * The database backend used to execute operations and handle results\n   */\n  static get database(): DatabaseBackend; // TODO: Reference type defined in CONFIG\n\n  /**\n   * Return a reference to the implemented subclass of this base document type.\n   */\n  static get implementation(): ConstructorOf<Document<any, any>>; // Referencing the concrete class the config is not possible because accessors cannot be generic and there is not static polymorphic this type\n\n  /**\n   * The named collection to which this Document belongs.\n   */\n  static get collectionName(): string;\n\n  /**\n   * The canonical name of this Document type, for example \"Actor\".\n   */\n  static get documentName(): string;\n\n  /**\n   * The named collection to which this Document belongs.\n   */\n  get collectionName(): string;\n\n  /**\n   * The canonical name of this Document type, for example \"Actor\".\n   */\n  get documentName(): string;\n\n  /**\n   * The canonical identifier for this Document\n   */\n  get id(): string | null;\n\n  /**\n   * Test whether this Document is embedded within a parent Document\n   */\n  get isEmbedded(): boolean;\n\n  /**\n   * The name of this Document, if it has one assigned\n   */\n  get name(): string | null;\n\n  /**\n   * Test whether a given User has a sufficient role in order to create Documents of this type.\n   * @param user - The User being tested\n   * @returns Does the User have a sufficient role to create?\n   */\n  static canUserCreate(user: BaseUser): boolean;\n\n  /**\n   * Clone a document, creating a new document by combining current data with provided overrides.\n   * The cloned document is ephemeral and not yet saved to the database.\n   * @param data   - Additional data which overrides current document data at the time of creation\n   *                 (default: `{}`)\n   * @param save   - Save the clone to the World database?\n   *                 (default: `false`)\n   * @param keepId - Keep the original Document ID? Otherwise the ID will become undefined\n   *                 (default: `false`)\n   * @returns The cloned Document instance\n   */\n  clone(\n    data?: DeepPartial<\n      ConstructorDataType<ConcreteDocumentData> | (ConstructorDataType<ConcreteDocumentData> & Record<string, unknown>)\n    >,\n    { save, keepId }?: { save?: boolean; keepId?: boolean }\n  ): TemporaryDocument<this> | Promise<TemporaryDocument<this> | undefined>;\n\n  /**\n   * Get the permission level that a specific User has over this Document, a value in CONST.ENTITY_PERMISSIONS.\n   * @param user - The User being tested\n   * @returns A numeric permission level from CONST.ENTITY_PERMISSIONS or null\n   */\n  getUserLevel(user: BaseUser): foundry.CONST.EntityPermission | null;\n\n  /**\n   * Test whether a certain User has a requested permission level (or greater) over the Document\n   * @param user       - The User being tested\n   * @param permission - The permission level from ENTITY_PERMISSIONS to test\n   * @param exact      - Require the exact permission level requested?\n   *                     (default: `false`)\n   * @returns Does the user have this permission level over the Document?\n   */\n  testUserPermission(\n    user: BaseUser,\n    permission: keyof typeof foundry.CONST.ENTITY_PERMISSIONS | foundry.CONST.EntityPermission,\n    { exact }?: { exact?: boolean }\n  ): boolean;\n\n  /**\n   * Test whether a given User has permission to perform some action on this Document\n   * @param user   - The User attempting modification\n   * @param action - The attempted action\n   * @param data   - Data involved in the attempted action\n   *                 (default: `{}`)\n   * @returns  Does the User have permission?\n   */\n  canUserModify(user: BaseUser, action: 'create' | 'update' | 'delete', data?: object): boolean;\n\n  /**\n   * Create multiple Documents using provided input data.\n   * Data is provided as an array of objects where each individual object becomes one new Document.\n   *\n   * @param data    - An array of data objects used to create multiple documents\n   *                  (default: `[]`)\n   * @param context - Additional context which customizes the creation workflow\n   *                  (default: `{}`)\n   * @returns An array of created Document instances\n   *Additional context which customizes the creation workflow\n   * @example <caption>Create a single Document</caption>\n   * ```typescript\n   * const data = [{name: \"New Actor\", type: \"character\", img: \"path/to/profile.jpg\"}];\n   * const created = await Actor.createDocuments(data);\n   * ```\n   *\n   * @example <caption>Create multiple Documents</caption>\n   * ```typescript\n   * const data = [{name: \"Tim\", type: \"npc\"], [{name: \"Tom\", type: \"npc\"}];\n   * const created = await Actor.createDocuments(data);\n   * ```\n   *\n   * @example <caption>Create multiple embedded Documents within a parent</caption>\n   * ```typescript\n   * const actor = game.actors.getName(\"Tim\");\n   * const data = [{name: \"Sword\", type: \"weapon\"}, {name: \"Breastplate\", type: \"equipment\"}];\n   * const created = await Item.createDocuments(data, {parent: actor});this\n   * ```\n   *\n   * @example <caption>Create a Document within a Compendium pack</caption>\n   * ```typescript\n   * const data = [{name: \"Compendium Actor\", type: \"character\", img: \"path/to/profile.jpg\"}];\n   * const created = await Actor.createDocuments(data, {pack: \"mymodule.mypack\"});\n   * ```\n   */\n  static createDocuments<T extends DocumentConstructor>(\n    this: T,\n    data: Array<\n      | ConstructorDataType<InstanceType<T>['data']>\n      | (ConstructorDataType<InstanceType<T>['data']> & Record<string, unknown>)\n    >,\n    context: DocumentModificationContext & { temporary: false }\n  ): Promise<StoredDocument<InstanceType<ConfiguredDocumentClass<T>>>[]>;\n  static createDocuments<T extends DocumentConstructor>(\n    this: T,\n    data: Array<\n      | ConstructorDataType<InstanceType<T>['data']>\n      | (ConstructorDataType<InstanceType<T>['data']> & Record<string, unknown>)\n    >,\n    context: DocumentModificationContext & { temporary: boolean }\n  ): Promise<InstanceType<ConfiguredDocumentClass<T>>[]>;\n  static createDocuments<T extends DocumentConstructor>(\n    this: T,\n    data?: Array<\n      | ConstructorDataType<InstanceType<T>['data']>\n      | (ConstructorDataType<InstanceType<T>['data']> & Record<string, unknown>)\n    >,\n    context?: DocumentModificationContext\n  ): Promise<StoredDocument<InstanceType<ConfiguredDocumentClass<T>>>[]>;\n\n  /**\n   * Update multiple Document instances using provided differential data.\n   * Data is provided as an array of objects where each individual object updates one existing Document.\n   *\n   * @param updates - An array of differential data objects, each used to update a single Document\n   *                  (default: `[]`)\n   * @param context - Additional context which customizes the update workflow\n   *                  (default: `{}`)\n   * @returns An array of updated Document instances\n   *\n   * @example <caption>Update a single Document</caption>\n   * ```typescript\n   * const updates = [{_id: \"12ekjf43kj2312ds\", name: \"Timothy\"}];\n   * const updated = await Actor.updateDocuments(updates);\n   * ```\n   *\n   * @example <caption>Update multiple Documents</caption>\n   * ```typescript\n   * const updates = [{_id: \"12ekjf43kj2312ds\", name: \"Timothy\"}, {_id: \"kj549dk48k34jk34\", name: \"Thomas\"}]};\n   * const updated = await Actor.updateDocuments(updates);\n   * ```\n   *\n   * @example <caption>Update multiple embedded Documents within a parent</caption>\n   * ```typescript\n   * const actor = game.actors.getName(\"Timothy\");\n   * const updates = [{_id: sword.id, name: \"Magic Sword\"}, {_id: shield.id, name: \"Magic Shield\"}];\n   * const updated = await Item.updateDocuments(updates, {parent: actor});\n   * ```\n   *\n   * @example <caption>Update Documents within a Compendium pack</caption>\n   * ```typescript\n   * const actor = await pack.getDocument(documentId);\n   * const updated = await Actor.updateDocuments([{_id: actor.id, name: \"New Name\"}], {pack: \"mymodule.mypack\"});\n   * ```\n   */\n  static updateDocuments<T extends DocumentConstructor>(\n    this: T,\n    updates?: Array<\n      DeepPartial<\n        | ConstructorDataType<InstanceType<T>['data']>\n        | (ConstructorDataType<InstanceType<T>['data']> & Record<string, unknown>)\n      >\n    >,\n    context?: DocumentModificationContext & foundry.utils.MergeObjectOptions\n  ): Promise<InstanceType<ConfiguredDocumentClass<T>>[]>;\n\n  /**\n   * Delete one or multiple existing Documents using an array of provided ids.\n   * Data is provided as an array of string ids for the documents to delete.\n   *\n   * @param ids - An array of string ids for the documents to be deleted\n   *              (default: `[]`)\n   * @param context - Additional context which customizes the update workflow\n   *                  (default: `{}`)\n   * @returns An array of deleted Document instances\n   *\n   * @example <caption>Delete a single Document</caption>\n   * ```typescript\n   * const tim = game.actors.getName(\"Tim\");\n   * const deleted = await Actor.deleteDocuments([tim.id]);\n   * ```\n   *\n   * @example <caption>Delete multiple Documents</caption>\n   * ```typescript\n   * const tim = game.actors.getName(\"Tim\");\n   * const tom = game.actors.getName(\"Tom\");\n   * const deleted = await Actor.deleteDocuments([tim.id, tom.id]);\n   * ```\n   *\n   * @example <caption>Delete multiple embedded Documents within a parent</caption>\n   * ```typescript\n   * const tim = game.actors.getName(\"Tim\");\n   * const sword = tim.items.getName(\"Sword\");\n   * const shield = tim.items.getName(\"Shield\");\n   * const deleted = await Item.deleteDocuments([sword.id, shield.id], parent: actor});\n   * ```\n   *\n   * @example <caption>Delete Documents within a Compendium pack</caption>\n   * ```typescript\n   * const actor = await pack.getDocument(documentId);\n   * const deleted = await Actor.deleteDocuments([actor.id], {pack: \"mymodule.mypack\"});\n   * ```\n   */\n  static deleteDocuments<T extends DocumentConstructor>(\n    this: T,\n    ids?: string[],\n    context?: DocumentModificationContext\n  ): Promise<InstanceType<ConfiguredDocumentClass<T>>[]>;\n\n  /**\n   * Create a new Document using provided input data, saving it to the database.\n   * @see {@link Document.createDocuments}\n   * @param data    - Initial data used to create this Document\n   * @param context - Additional context which customizes the creation workflow\n   *                  (default: `{}`)\n   * @returns The created Document instance\n   *\n   * @example <caption>Create a World-level Item</caption>\n   * ```typescript\n   * const data = [{name: \"Special Sword\", type: \"weapon\"}];\n   * const created = await Item.create(data);\n   * ```\n   *\n   * @example <caption>Create an Actor-owned Item</caption>\n   * ```typescript\n   * const data = [{name: \"Special Sword\", type: \"weapon\"}];\n   * const actor = game.actors.getName(\"My Hero\");\n   * const created = await Item.create(data, {parent: actor});\n   * ```\n   *\n   * @example <caption>Create an Item in a Compendium pack</caption>\n   * ```typescript\n   * const data = [{name: \"Special Sword\", type: \"weapon\"}];\n   * const created = await Item.create(data, {pack: \"mymodule.mypack\"});\n   * ```\n   *\n   * @remarks If no document has actually been created, the returned {@link Promise} resolves to `undefined`.\n   */\n  static create<T extends DocumentConstructor>(\n    this: T,\n    data:\n      | ConstructorDataType<InstanceType<T>['data']>\n      | (ConstructorDataType<InstanceType<T>['data']> & Record<string, unknown>),\n    context: DocumentModificationContext & { temporary: false }\n  ): Promise<StoredDocument<InstanceType<ConfiguredDocumentClass<T>>> | undefined>;\n  static create<T extends DocumentConstructor>(\n    this: T,\n    data:\n      | ConstructorDataType<InstanceType<T>['data']>\n      | (ConstructorDataType<InstanceType<T>['data']> & Record<string, unknown>),\n    context: DocumentModificationContext & { temporary: boolean }\n  ): Promise<InstanceType<ConfiguredDocumentClass<T>> | undefined>;\n  static create<T extends DocumentConstructor>(\n    this: T,\n    data:\n      | ConstructorDataType<InstanceType<T>['data']>\n      | (ConstructorDataType<InstanceType<T>['data']> & Record<string, unknown>),\n    context?: DocumentModificationContext\n  ): Promise<StoredDocument<InstanceType<ConfiguredDocumentClass<T>>> | undefined>;\n\n  /**\n   * Update this Document using incremental data, saving it to the database.\n   * @see {@link Document.updateDocuments}\n   * @param data    - Differential update data which modifies the existing values of this document data\n   *                  (default: `{}`)\n   * @param context - Additional context which customizes the update workflow\n   *                  (default: `{}`)\n   * @returns The updated Document instance\n   *\n   * @remarks If no document has actually been updated, the returned {@link Promise} resolves to `undefined`.\n   */\n  update(\n    data?: DeepPartial<\n      ConstructorDataType<ConcreteDocumentData> | (ConstructorDataType<ConcreteDocumentData> & Record<string, unknown>)\n    >,\n    context?: DocumentModificationContext & foundry.utils.MergeObjectOptions\n  ): Promise<this | undefined>;\n\n  /**\n   * Delete this Document, removing it from the database.\n   * @see {@link Document.deleteDocuments}\n   * @param context - Additional context which customizes the deletion workflow\n   *                  (default: `{}`)\n   * @returns The deleted Document instance\n   *\n   * @remarks If no document has actually been deleted, the returned {@link Promise} resolves to `undefined`.\n   */\n  delete(context?: DocumentModificationContext): Promise<this | undefined>;\n\n  /**\n   * Obtain a reference to the Array of source data within the data object for a certain embedded Document name\n   * @param embeddedName - The name of the embedded Document type\n   * @returns The Collection instance of embedded Documents of the requested type\n   */\n  getEmbeddedCollection(embeddedName: string): EmbeddedCollection<DocumentConstructor, AnyDocumentData>; // TODO: Improve\n\n  /**\n   * Get an embedded document by it's id from a named collection in the parent document.\n   * @param embeddedName - The name of the embedded Document type\n   * @param id           - The id of the child document to retrieve\n   * @param options      - Additional options which modify how embedded documents are retrieved\n   * @param strict       - Throw an Error if the requested id does not exist. See Collection#get\n   *                       (default: `false`)\n   * @returns The retrieved embedded Document instance, or undefined\n   */\n  getEmbeddedDocument(\n    embeddedName: string,\n    id: string,\n    { strict }?: { strict?: boolean }\n  ): Document<any, this> | undefined;\n\n  /**\n   * Create multiple embedded Document instances within this parent Document using provided input data.\n   * @see {@link Document.createDocuments}\n   * @param embeddedName - The name of the embedded Document type\n   * @param data         - An array of data objects used to create multiple documents\n   *                       (default: `[]`)\n   * @param context      - Additional context which customizes the creation workflow\n   *                       (default: `{}`)\n   * @returns An array of created Document instances\n   */\n  createEmbeddedDocuments(\n    embeddedName: string,\n    data: Array<Record<string, unknown>>,\n    context: DocumentModificationContext & { temporary: false }\n  ): Promise<Array<StoredDocument<Document<any, this>>>>;\n  createEmbeddedDocuments(\n    embeddedName: string,\n    data: Array<Record<string, unknown>>,\n    context: DocumentModificationContext & { temporary: boolean }\n  ): Promise<Array<Document<any, this>>>;\n  createEmbeddedDocuments(\n    embeddedName: string,\n    data: Array<Record<string, unknown>>,\n    context?: DocumentModificationContext\n  ): Promise<Array<StoredDocument<Document<any, this>>>>;\n\n  /**\n   * Update multiple embedded Document instances within a parent Document using provided differential data.\n   * @see {@link Document.updateDocuments}\n   * @param embeddedName - The name of the embedded Document type\n   * @param updates      - An array of differential data objects, each used to update a single Document\n   *                       (default: `[]`)\n   * @param context      - Additional context which customizes the creation workflow\n   *                       (default: `{}`)\n   * @returns An array of updated Document instances\n   */\n  updateEmbeddedDocuments(\n    embeddedName: string,\n    updates?: Array<Record<string, unknown>>,\n    context?: DocumentModificationContext\n  ): Promise<Array<Document<any, this>>>;\n\n  /**\n   * Delete multiple embedded Document instances within a parent Document using provided string ids.\n   * @see {@link Document.deleteDocuments}\n   * @param embeddedName - The name of the embedded Document type\n   * @param ids          - An array of string ids for each Document to be deleted\n   * @param context      - Additional context which customizes the deletion workflow\n   *                       (default: `{}`)\n   * @returns An array of deleted Document instances\n   */\n  deleteEmbeddedDocuments(\n    embeddedName: string,\n    ids: Array<string>,\n    context?: DocumentModificationContext\n  ): Promise<Array<Document<any, this>>>;\n\n  /**\n   * Get the value of a \"flag\" for this document\n   * See the setFlag method for more details on flags\n   *\n   * @param scope - The flag scope which namespaces the key\n   * @param key   - The flag key\n   * @returns The flag value\n   */\n  getFlag<\n    S extends keyof ConcreteDocumentData['_source']['flags'],\n    K extends keyof ConcreteDocumentData['_source']['flags'][S]\n  >(scope: S, key: K): ConcreteDocumentData['_source']['flags'][S][K];\n  getFlag<\n    S extends keyof ConcreteDocumentData['_source']['flags'],\n    K extends keyof Required<ConcreteDocumentData['_source']['flags']>[S]\n  >(scope: S, key: K): Required<ConcreteDocumentData['_source']['flags']>[S][K] | undefined;\n  getFlag<S extends keyof ConcreteDocumentData['_source']['flags']>(\n    scope: S,\n    key: string\n  ): unknown extends ConcreteDocumentData['_source']['flags'][S] ? unknown : never;\n  getFlag(scope: string, key: string): unknown;\n\n  /**\n   * Assign a \"flag\" to this document.\n   * Flags represent key-value type data which can be used to store flexible or arbitrary data required by either\n   * the core software, game systems, or user-created modules.\n   *\n   * Each flag should be set using a scope which provides a namespace for the flag to help prevent collisions.\n   *\n   * Flags set by the core software use the \"core\" scope.\n   * Flags set by game systems or modules should use the canonical name attribute for the module\n   * Flags set by an individual world should \"world\" as the scope.\n   *\n   * Flag values can assume almost any data type. Setting a flag value to null will delete that flag.\n   *\n   * @param scope - The flag scope which namespaces the key\n   * @param key   - The flag key\n   * @param value - The flag value\n   * @returns A Promise resolving to the updated document\n   */\n  setFlag<\n    S extends keyof ConcreteDocumentData['_source']['flags'],\n    K extends keyof Required<ConcreteDocumentData['_source']['flags']>[S],\n    V extends Required<ConcreteDocumentData['_source']['flags']>[S][K]\n  >(scope: S, key: K, value: V): Promise<this>;\n  setFlag<S extends keyof ConcreteDocumentData['_source']['flags'], K extends string>(\n    scope: S,\n    key: K,\n    v: unknown extends ConcreteDocumentData['_source']['flags'][S] ? unknown : never\n  ): Promise<this>;\n\n  /**\n   * Remove a flag assigned to the document\n   * @param scope - The flag scope which namespaces the key\n   * @param key   - The flag key\n   * @returns The updated document instance\n   */\n  unsetFlag(scope: string, key: string): Promise<this>;\n\n  /**\n   * Perform preliminary operations before a Document of this type is created.\n   * Pre-creation operations only occur for the client which requested the operation.\n   * @param data    - The initial data used to create the document\n   * @param options - Additional options which modify the creation request\n   * @param user    - The User requesting the document creation\n   */\n  protected _preCreate(\n    data: ConstructorDataType<ConcreteDocumentData>,\n    options: DocumentModificationOptions,\n    user: BaseUser\n  ): Promise<void>;\n\n  /**\n   * Perform preliminary operations before a Document of this type is updated.\n   * Pre-update operations only occur for the client which requested the operation.\n   * @param changed - The differential data that is changed relative to the documents prior values\n   * @param options - Additional options which modify the update request\n   * @param user    - The User requesting the document update\n   */\n  protected _preUpdate(\n    changed: DeepPartial<ConstructorDataType<ConcreteDocumentData>>,\n    options: DocumentModificationOptions,\n    user: BaseUser\n  ): Promise<void>;\n\n  /**\n   * Perform preliminary operations before a Document of this type is deleted.\n   * Pre-delete operations only occur for the client which requested the operation.\n   * @param options - Additional options which modify the deletion request\n   * @param user    - The User requesting the document deletion\n   */\n  protected _preDelete(options: DocumentModificationOptions, user: BaseUser): Promise<void>;\n\n  /**\n   * Perform follow-up operations after a Document of this type is created.\n   * Post-creation operations occur for all clients after the creation is broadcast.\n   * @param data   - The data from which the document was created\n   * @param options- Additional options which modify the creation request\n   * @param user   - The id of the User requesting the document update\n   */\n  protected _onCreate(\n    data: ConcreteDocumentData['_source'],\n    options: DocumentModificationOptions,\n    userId: string\n  ): void;\n\n  /**\n   * Perform follow-up operations after a Document of this type is updated.\n   * Post-update operations occur for all clients after the update is broadcast.\n   * @param changed - The differential data that was changed relative to the documents prior values\n   * @param options - Additional options which modify the update request\n   * @param user    - The id of the User requesting the document update\n   */\n  protected _onUpdate(\n    changed: DeepPartial<ConcreteDocumentData['_source']>,\n    options: DocumentModificationOptions,\n    userId: string\n  ): void;\n\n  /**\n   * Perform follow-up operations after a Document of this type is deleted.\n   * Post-deletion operations occur for all clients after the deletion is broadcast.\n   * @param options- Additional options which modify the deletion request\n   * @param user   - The id of the User requesting the document update\n   */\n  protected _onDelete(options: DocumentModificationOptions, userId: string): void;\n\n  /**\n   * Perform follow-up operations when a set of Documents of this type are created.\n   * This is where side effects of creation should be implemented.\n   * Post-creation side effects are performed only for the client which requested the operation.\n   * @param documents- The Document instances which were created\n   * @param context  - The context for the modification operation\n   *\n   * @remarks The base implementation returns `void` but it is typed as\n   * `unknown` to allow deriving classes to return whatever they want. The\n   * return type is not meant to be used.\n   */\n  protected static _onCreateDocuments<T extends DocumentConstructor>(\n    this: T,\n    documents: Array<InstanceType<ConfiguredDocumentClass<T>>>,\n    context: DocumentModificationContext\n  ): Promise<unknown>;\n\n  /**\n   * Perform follow-up operations when a set of Documents of this type are updated.\n   * This is where side effects of updates should be implemented.\n   * Post-update side effects are performed only for the client which requested the operation.\n   * @param documents - The Document instances which were updated\n   * @param context   - The context for the modification operation\n   *\n   * @remarks The base implementation returns `void` but it is typed as\n   * `unknown` to allow deriving classes to return whatever they want. The\n   * return type is not meant to be used.\n   */\n  protected static _onUpdateDocuments<T extends DocumentConstructor>(\n    this: T,\n    documents: Array<InstanceType<ConfiguredDocumentClass<T>>>,\n    context: DocumentModificationContext\n  ): Promise<unknown>;\n\n  /**\n   * Perform follow-up operations when a set of Documents of this type are deleted.\n   * This is where side effects of deletion should be implemented.\n   * Post-deletion side effects are performed only for the client which requested the operation.\n   * @param documents - The Document instances which were deleted\n   * @param context   - The context for the modification operation\n   *\n   * @remarks The base implementation returns `void` but it is typed as\n   * `unknown` to allow deriving classes to return whatever they want. The\n   * return type is not meant to be used.\n   */\n  protected static _onDeleteDocuments<T extends DocumentConstructor>(\n    this: T,\n    documents: Array<InstanceType<ConfiguredDocumentClass<T>>>,\n    context: DocumentModificationContext\n  ): Promise<unknown>;\n\n  /**\n   * Transform the Document instance into a plain object.\n   * The created object is an independent copy of the original data.\n   * See DocumentData#toObject\n   * @param source - Draw values from the underlying data source rather than transformed values\n   * @returns The extracted primitive object\n   */\n  toObject(source?: true): ReturnType<this['toJSON']>;\n  toObject(\n    source: false\n  ): this['id'] extends string\n    ? ToObjectFalseType<ConcreteDocumentData> & { _id: string }\n    : ToObjectFalseType<ConcreteDocumentData>;\n\n  /**\n   * Convert the Document instance to a primitive object which can be serialized.\n   * See DocumentData#toJSON\n   * @returns The document data expressed as a plain object\n   */\n  toJSON(): this['id'] extends string\n    ? ReturnType<ConcreteDocumentData['toJSON']> & { _id: string }\n    : ReturnType<ConcreteDocumentData['toJSON']>;\n}\n\nexport interface DocumentModificationOptions {\n  /**\n   * Block the dispatch of preCreate hooks for this operation\n   * @defaultValue `false`\n   */\n  noHook?: boolean;\n\n  /**\n   * Return an index of the Document collection, used only during a get operation.\n   * @defaultValue `false`\n   */\n  index?: boolean;\n\n  /**\n   * When performing a creation operation, keep the provided _id instead of clearing it.\n   * @defaultValue `false`\n   */\n  keepId?: boolean;\n\n  /**\n   * Create a temporary document which is not saved to the database. Only used during creation.\n   * @defaultValue `false`\n   */\n  temporary?: boolean;\n\n  /**\n   * Automatically re-render existing applications associated with the document.\n   * @defaultValue `true`\n   */\n  render?: boolean;\n\n  /**\n   * Automatically create and render the Document sheet when the Document is first created.\n   * @defaultValue `false`\n   */\n  renderSheet?: boolean;\n\n  /**\n   * Difference each update object against current Document data to reduce the size of the transferred data. Only used during update.\n   * @defaultValue `true`\n   */\n  diff?: boolean;\n\n  /**\n   * Merge objects recursively. If false, inner objects will be replaced explicitly. Use with caution!\n   * @defaultValue `true`\n   */\n  recursive?: boolean;\n\n  /**\n   * Is the operation undoing a previous operation, only used by embedded Documents within a Scene\n   */\n  isUndo?: boolean;\n\n  /**\n   * Whether to delete all documents of a given type, regardless of the array of ids provided. Only used during a delete operation.\n   */\n  deleteAll?: boolean;\n}\n\ndeclare global {\n  interface DocumentModificationContext extends DocumentModificationOptions {\n    /**\n     * A parent Document within which these Documents should be embedded\n     */\n    parent?: Document<any, any>;\n\n    /**\n     * A Compendium pack identifier within which the Documents should be modified\n     */\n    pack?: string;\n  }\n}\n\nexport interface Context<Parent extends Document<any, any> | null> {\n  /**\n   * A parent document within which this Document is embedded\n   */\n  parent?: Parent;\n\n  /**\n   * A named compendium pack within which this Document exists\n   */\n  pack?: string;\n}\n\nexport interface Metadata<ConcreteDocument extends Document<any, any>> {\n  name: DocumentType;\n  collection: string;\n  label: string;\n  types: string[] | Record<string, unknown>; // TODO: Record<string, unknown> is only there because In BaseTableResult this is set to CONST.TABLE_RESULT_TYPES, check if this is a bug in foundry\n  embedded: Record<string, ConstructorOf<Document<any, any>>>;\n  hasSystemData: boolean;\n  permissions: {\n    create: string | ((user: BaseUser, doc: ConcreteDocument, data?: object) => boolean); // data isn't actually ever passed in on the client side\n    update: string | ((user: BaseUser, doc: ConcreteDocument, data?: object) => boolean); // data isn't actually ever passed in on the client side\n    delete: string | ((user: BaseUser, doc: ConcreteDocument, data?: object) => boolean); // data isn't actually ever passed in on the client side\n  };\n  pack: any;\n}\n\nexport interface DocumentMetadata {\n  name: 'Document';\n  collection: 'documents';\n  label: 'DOCUMENT.Document';\n  types: [];\n  embedded: {};\n  hasSystemData: false;\n  permissions: {\n    create: 'ASSISTANT';\n    update: 'ASSISTANT';\n    delete: 'ASSISTANT';\n  };\n  pack: null;\n}\n\nexport default Document;\n"
    ]
  