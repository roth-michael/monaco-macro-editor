
    export default [
      "socket.io-client/build/manager.d.ts",
      "import { Socket, SocketOptions } from \"./socket\";\nimport { Packet } from \"socket.io-parser\";\nimport { DefaultEventsMap, EventsMap, StrictEventEmitter } from \"./typed-events\";\ninterface EngineOptions {\n    /**\n     * The host that we're connecting to. Set from the URI passed when connecting\n     */\n    host: string;\n    /**\n     * The hostname for our connection. Set from the URI passed when connecting\n     */\n    hostname: string;\n    /**\n     * If this is a secure connection. Set from the URI passed when connecting\n     */\n    secure: boolean;\n    /**\n     * The port for our connection. Set from the URI passed when connecting\n     */\n    port: string;\n    /**\n     * Any query parameters in our uri. Set from the URI passed when connecting\n     */\n    query: {\n        [key: string]: string;\n    };\n    /**\n     * `http.Agent` to use, defaults to `false` (NodeJS only)\n     */\n    agent: string | boolean;\n    /**\n     * Whether the client should try to upgrade the transport from\n     * long-polling to something better.\n     * @default true\n     */\n    upgrade: boolean;\n    /**\n     * Forces JSONP for polling transport.\n     */\n    forceJSONP: boolean;\n    /**\n     * Determines whether to use JSONP when necessary for polling. If\n     * disabled (by settings to false) an error will be emitted (saying\n     * \"No transports available\") if no other transports are available.\n     * If another transport is available for opening a connection (e.g.\n     * WebSocket) that transport will be used instead.\n     * @default true\n     */\n    jsonp: boolean;\n    /**\n     * Forces base 64 encoding for polling transport even when XHR2\n     * responseType is available and WebSocket even if the used standard\n     * supports binary.\n     */\n    forceBase64: boolean;\n    /**\n     * Enables XDomainRequest for IE8 to avoid loading bar flashing with\n     * click sound. default to `false` because XDomainRequest has a flaw\n     * of not sending cookie.\n     * @default false\n     */\n    enablesXDR: boolean;\n    /**\n     * The param name to use as our timestamp key\n     * @default 't'\n     */\n    timestampParam: string;\n    /**\n     * Whether to add the timestamp with each transport request. Note: this\n     * is ignored if the browser is IE or Android, in which case requests\n     * are always stamped\n     * @default false\n     */\n    timestampRequests: boolean;\n    /**\n     * A list of transports to try (in order). Engine.io always attempts to\n     * connect directly with the first one, provided the feature detection test\n     * for it passes.\n     * @default ['polling','websocket']\n     */\n    transports: string[];\n    /**\n     * The port the policy server listens on\n     * @default 843\n     */\n    policyPost: number;\n    /**\n     * If true and if the previous websocket connection to the server succeeded,\n     * the connection attempt will bypass the normal upgrade process and will\n     * initially try websocket. A connection attempt following a transport error\n     * will use the normal upgrade process. It is recommended you turn this on\n     * only when using SSL/TLS connections, or if you know that your network does\n     * not block websockets.\n     * @default false\n     */\n    rememberUpgrade: boolean;\n    /**\n     * Are we only interested in transports that support binary?\n     */\n    onlyBinaryUpgrades: boolean;\n    /**\n     * Timeout for xhr-polling requests in milliseconds (0) (only for polling transport)\n     */\n    requestTimeout: number;\n    /**\n     * Transport options for Node.js client (headers etc)\n     */\n    transportOptions: Object;\n    /**\n     * (SSL) Certificate, Private key and CA certificates to use for SSL.\n     * Can be used in Node.js client environment to manually specify\n     * certificate information.\n     */\n    pfx: string;\n    /**\n     * (SSL) Private key to use for SSL. Can be used in Node.js client\n     * environment to manually specify certificate information.\n     */\n    key: string;\n    /**\n     * (SSL) A string or passphrase for the private key or pfx. Can be\n     * used in Node.js client environment to manually specify certificate\n     * information.\n     */\n    passphrase: string;\n    /**\n     * (SSL) Public x509 certificate to use. Can be used in Node.js client\n     * environment to manually specify certificate information.\n     */\n    cert: string;\n    /**\n     * (SSL) An authority certificate or array of authority certificates to\n     * check the remote host against.. Can be used in Node.js client\n     * environment to manually specify certificate information.\n     */\n    ca: string | string[];\n    /**\n     * (SSL) A string describing the ciphers to use or exclude. Consult the\n     * [cipher format list]\n     * (http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT) for\n     * details on the format.. Can be used in Node.js client environment to\n     * manually specify certificate information.\n     */\n    ciphers: string;\n    /**\n     * (SSL) If true, the server certificate is verified against the list of\n     * supplied CAs. An 'error' event is emitted if verification fails.\n     * Verification happens at the connection level, before the HTTP request\n     * is sent. Can be used in Node.js client environment to manually specify\n     * certificate information.\n     */\n    rejectUnauthorized: boolean;\n    /**\n     * Headers that will be passed for each request to the server (via xhr-polling and via websockets).\n     * These values then can be used during handshake or for special proxies.\n     */\n    extraHeaders?: {\n        [header: string]: string;\n    };\n    /**\n     * Whether to include credentials (cookies, authorization headers, TLS\n     * client certificates, etc.) with cross-origin XHR polling requests\n     * @default false\n     */\n    withCredentials: boolean;\n    /**\n     * Whether to automatically close the connection whenever the beforeunload event is received.\n     * @default true\n     */\n    closeOnBeforeunload: boolean;\n}\nexport interface ManagerOptions extends EngineOptions {\n    /**\n     * Should we force a new Manager for this connection?\n     * @default false\n     */\n    forceNew: boolean;\n    /**\n     * Should we multiplex our connection (reuse existing Manager) ?\n     * @default true\n     */\n    multiplex: boolean;\n    /**\n     * The path to get our client file from, in the case of the server\n     * serving it\n     * @default '/socket.io'\n     */\n    path: string;\n    /**\n     * Should we allow reconnections?\n     * @default true\n     */\n    reconnection: boolean;\n    /**\n     * How many reconnection attempts should we try?\n     * @default Infinity\n     */\n    reconnectionAttempts: number;\n    /**\n     * The time delay in milliseconds between reconnection attempts\n     * @default 1000\n     */\n    reconnectionDelay: number;\n    /**\n     * The max time delay in milliseconds between reconnection attempts\n     * @default 5000\n     */\n    reconnectionDelayMax: number;\n    /**\n     * Used in the exponential backoff jitter when reconnecting\n     * @default 0.5\n     */\n    randomizationFactor: number;\n    /**\n     * The timeout in milliseconds for our connection attempt\n     * @default 20000\n     */\n    timeout: number;\n    /**\n     * Should we automatically connect?\n     * @default true\n     */\n    autoConnect: boolean;\n    /**\n     * weather we should unref the reconnect timer when it is\n     * create automatically\n     * @default false\n     */\n    autoUnref: boolean;\n    /**\n     * the parser to use. Defaults to an instance of the Parser that ships with socket.io.\n     */\n    parser: any;\n}\ninterface ManagerReservedEvents {\n    open: () => void;\n    error: (err: Error) => void;\n    ping: () => void;\n    packet: (packet: Packet) => void;\n    close: (reason: string) => void;\n    reconnect_failed: () => void;\n    reconnect_attempt: (attempt: number) => void;\n    reconnect_error: (err: Error) => void;\n    reconnect: (attempt: number) => void;\n}\nexport declare class Manager<ListenEvents extends EventsMap = DefaultEventsMap, EmitEvents extends EventsMap = ListenEvents> extends StrictEventEmitter<{}, {}, ManagerReservedEvents> {\n    /**\n     * The Engine.IO client instance\n     *\n     * @public\n     */\n    engine: any;\n    /**\n     * @private\n     */\n    _autoConnect: boolean;\n    /**\n     * @private\n     */\n    _readyState: \"opening\" | \"open\" | \"closed\";\n    /**\n     * @private\n     */\n    _reconnecting: boolean;\n    private readonly uri;\n    opts: Partial<ManagerOptions>;\n    private nsps;\n    private subs;\n    private backoff;\n    private _reconnection;\n    private _reconnectionAttempts;\n    private _reconnectionDelay;\n    private _randomizationFactor;\n    private _reconnectionDelayMax;\n    private _timeout;\n    private encoder;\n    private decoder;\n    private skipReconnect;\n    /**\n     * `Manager` constructor.\n     *\n     * @param uri - engine instance or engine uri/opts\n     * @param opts - options\n     * @public\n     */\n    constructor(opts: Partial<ManagerOptions>);\n    constructor(uri?: string, opts?: Partial<ManagerOptions>);\n    constructor(uri?: string | Partial<ManagerOptions>, opts?: Partial<ManagerOptions>);\n    /**\n     * Sets the `reconnection` config.\n     *\n     * @param {Boolean} v - true/false if it should automatically reconnect\n     * @return {Manager} self or value\n     * @public\n     */\n    reconnection(v: boolean): this;\n    reconnection(): boolean;\n    reconnection(v?: boolean): this | boolean;\n    /**\n     * Sets the reconnection attempts config.\n     *\n     * @param {Number} v - max reconnection attempts before giving up\n     * @return {Manager} self or value\n     * @public\n     */\n    reconnectionAttempts(v: number): this;\n    reconnectionAttempts(): number;\n    reconnectionAttempts(v?: number): this | number;\n    /**\n     * Sets the delay between reconnections.\n     *\n     * @param {Number} v - delay\n     * @return {Manager} self or value\n     * @public\n     */\n    reconnectionDelay(v: number): this;\n    reconnectionDelay(): number;\n    reconnectionDelay(v?: number): this | number;\n    /**\n     * Sets the randomization factor\n     *\n     * @param v - the randomization factor\n     * @return self or value\n     * @public\n     */\n    randomizationFactor(v: number): this;\n    randomizationFactor(): number;\n    randomizationFactor(v?: number): this | number;\n    /**\n     * Sets the maximum delay between reconnections.\n     *\n     * @param v - delay\n     * @return self or value\n     * @public\n     */\n    reconnectionDelayMax(v: number): this;\n    reconnectionDelayMax(): number;\n    reconnectionDelayMax(v?: number): this | number;\n    /**\n     * Sets the connection timeout. `false` to disable\n     *\n     * @param v - connection timeout\n     * @return self or value\n     * @public\n     */\n    timeout(v: number | boolean): this;\n    timeout(): number | boolean;\n    timeout(v?: number | boolean): this | number | boolean;\n    /**\n     * Starts trying to reconnect if reconnection is enabled and we have not\n     * started reconnecting yet\n     *\n     * @private\n     */\n    private maybeReconnectOnOpen;\n    /**\n     * Sets the current transport `socket`.\n     *\n     * @param {Function} fn - optional, callback\n     * @return self\n     * @public\n     */\n    open(fn?: (err?: Error) => void): this;\n    /**\n     * Alias for open()\n     *\n     * @return self\n     * @public\n     */\n    connect(fn?: (err?: Error) => void): this;\n    /**\n     * Called upon transport open.\n     *\n     * @private\n     */\n    private onopen;\n    /**\n     * Called upon a ping.\n     *\n     * @private\n     */\n    private onping;\n    /**\n     * Called with data.\n     *\n     * @private\n     */\n    private ondata;\n    /**\n     * Called when parser fully decodes a packet.\n     *\n     * @private\n     */\n    private ondecoded;\n    /**\n     * Called upon socket error.\n     *\n     * @private\n     */\n    private onerror;\n    /**\n     * Creates a new socket for the given `nsp`.\n     *\n     * @return {Socket}\n     * @public\n     */\n    socket(nsp: string, opts?: Partial<SocketOptions>): Socket;\n    /**\n     * Called upon a socket close.\n     *\n     * @param socket\n     * @private\n     */\n    _destroy(socket: Socket): void;\n    /**\n     * Writes a packet.\n     *\n     * @param packet\n     * @private\n     */\n    _packet(packet: Partial<Packet & {\n        query: string;\n        options: any;\n    }>): void;\n    /**\n     * Clean up transport subscriptions and packet buffer.\n     *\n     * @private\n     */\n    private cleanup;\n    /**\n     * Close the current socket.\n     *\n     * @private\n     */\n    _close(): void;\n    /**\n     * Alias for close()\n     *\n     * @private\n     */\n    private disconnect;\n    /**\n     * Called upon engine close.\n     *\n     * @private\n     */\n    private onclose;\n    /**\n     * Attempt a reconnection.\n     *\n     * @private\n     */\n    private reconnect;\n    /**\n     * Called upon successful reconnect.\n     *\n     * @private\n     */\n    private onreconnect;\n}\nexport {};\n"
    ]
  