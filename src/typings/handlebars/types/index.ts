
    export default [
      "handlebars/types/index.d.ts",
      "/* These definitions were imported from https://github.com/DefinitelyTyped/DefinitelyTyped\n * and includes previous contributions from the DefinitelyTyped community by:\n *   - Albert Willemsen <https://github.com/AlbertWillemsen-Centric>\n *   - Boris Yankov <https://github.com/borisyankov>\n *   - Jessica Franco <https://github.com/Kovensky>\n *   - Masahiro Wakame <https://github.com/vvakame>\n *   - Raanan Weber <https://github.com/RaananW>\n *   - Sergei Dorogin <https://github.com/evil-shrike>\n *   - webbiesdk <https://github.com/webbiesdk>\n *   - Andrew Leedham <https://github.com/AndrewLeedham>\n *   - Nils Knappmeier <https://github.com/nknapp>\n * For full history prior to their migration to handlebars.js, please see:\n * https://github.com/DefinitelyTyped/DefinitelyTyped/commits/1ce60bdc07f10e0b076778c6c953271c072bc894/types/handlebars/index.d.ts\n */\n// TypeScript Version: 2.3\n\ndeclare namespace Handlebars {\n  export interface TemplateDelegate<T = any> {\n      (context: T, options?: RuntimeOptions): string;\n  }\n\n  export type Template<T = any> = TemplateDelegate<T>|string;\n\n  export interface RuntimeOptions {\n      partial?: boolean;\n      depths?: any[];\n      helpers?: { [name: string]: Function };\n      partials?: { [name: string]: HandlebarsTemplateDelegate };\n      decorators?: { [name: string]: Function };\n      data?: any;\n      blockParams?: any[];\n      allowCallsToHelperMissing?: boolean;\n      allowedProtoProperties?: { [name: string]: boolean };\n      allowedProtoMethods?: { [name: string]: boolean };\n      allowProtoPropertiesByDefault?: boolean;\n      allowProtoMethodsByDefault?: boolean;\n  }\n\n  export interface HelperOptions {\n      fn: TemplateDelegate;\n      inverse: TemplateDelegate;\n      hash: any;\n      data?: any;\n  }\n\n  export interface HelperDelegate {\n      (context?: any, arg1?: any, arg2?: any, arg3?: any, arg4?: any, arg5?: any, options?: HelperOptions): any;\n  }\n  export interface HelperDeclareSpec {\n      [key: string]: HelperDelegate;\n  }\n\n  export interface ParseOptions {\n      srcName?: string;\n      ignoreStandalone?: boolean;\n  }\n\n  export function registerHelper(name: string, fn: HelperDelegate): void;\n  export function registerHelper(name: HelperDeclareSpec): void;\n  export function unregisterHelper(name: string): void;\n\n  export function registerPartial(name: string, fn: Template): void;\n  export function registerPartial(spec: { [name: string]: HandlebarsTemplateDelegate }): void;\n  export function unregisterPartial(name: string): void;\n\n  // TODO: replace Function with actual signature\n  export function registerDecorator(name: string, fn: Function): void;\n  export function unregisterDecorator(name: string): void;\n\n  export function K(): void;\n  export function createFrame(object: any): any;\n  export function blockParams(obj: any[], ids: any[]): any[];\n  export function log(level: number, obj: any): void;\n  export function parse(input: string, options?: ParseOptions): hbs.AST.Program;\n  export function parseWithoutProcessing(input: string, options?: ParseOptions): hbs.AST.Program;\n  export function compile<T = any>(input: any, options?: CompileOptions): HandlebarsTemplateDelegate<T>;\n  export function precompile(input: any, options?: PrecompileOptions): TemplateSpecification;\n  export function template<T = any>(precompilation: TemplateSpecification): HandlebarsTemplateDelegate<T>;\n\n  export function create(): typeof Handlebars;\n\n  export const escapeExpression: typeof Utils.escapeExpression;\n  //export const Utils: typeof hbs.Utils;\n  export const logger: Logger;\n  export const templates: HandlebarsTemplates;\n  export const helpers: { [name: string]: HelperDelegate };\n  export const partials: { [name: string]: any };\n  // TODO: replace Function with actual signature\n  export const decorators: { [name: string]: Function };\n\n  export const VERSION: string;\n\n  export function noConflict(): typeof Handlebars;\n\n  export class Exception {\n      constructor(message: string, node?: hbs.AST.Node);\n      description: string;\n      fileName: string;\n      lineNumber?: any;\n      endLineNumber?: any;\n      message: string;\n      name: string;\n      number: number;\n      stack?: string;\n      column?: any;\n      endColumn?: any;\n  }\n\n  export class SafeString {\n      constructor(str: string);\n      toString(): string;\n      toHTML(): string;\n  }\n\n  export namespace Utils {\n      export function escapeExpression(str: string): string;\n      export function createFrame(object: any): any;\n      export function blockParams(obj: any[], ids: any[]): any[];\n      export function isEmpty(obj: any) : boolean;\n      export function extend(obj: any, ...source: any[]): any;\n      export function toString(obj: any): string;\n      export function isArray(obj: any): boolean;\n      export function isFunction(obj: any): boolean;\n  }\n\n  export namespace AST {\n      export const helpers: hbs.AST.helpers;\n  }\n\n  interface ICompiler {\n      accept(node: hbs.AST.Node): void;\n      Program(program: hbs.AST.Program): void;\n      BlockStatement(block: hbs.AST.BlockStatement): void;\n      PartialStatement(partial: hbs.AST.PartialStatement): void;\n      PartialBlockStatement(partial: hbs.AST.PartialBlockStatement): void;\n      DecoratorBlock(decorator: hbs.AST.DecoratorBlock): void;\n      Decorator(decorator: hbs.AST.Decorator): void;\n      MustacheStatement(mustache: hbs.AST.MustacheStatement): void;\n      ContentStatement(content: hbs.AST.ContentStatement): void;\n      CommentStatement(comment?: hbs.AST.CommentStatement): void;\n      SubExpression(sexpr: hbs.AST.SubExpression): void;\n      PathExpression(path: hbs.AST.PathExpression): void;\n      StringLiteral(str: hbs.AST.StringLiteral): void;\n      NumberLiteral(num: hbs.AST.NumberLiteral): void;\n      BooleanLiteral(bool: hbs.AST.BooleanLiteral): void;\n      UndefinedLiteral(): void;\n      NullLiteral(): void;\n      Hash(hash: hbs.AST.Hash): void;\n  }\n\n  export class Visitor implements ICompiler {\n      accept(node: hbs.AST.Node): void;\n      acceptKey(node: hbs.AST.Node, name: string): void;\n      acceptArray(arr: hbs.AST.Expression[]): void;\n      Program(program: hbs.AST.Program): void;\n      BlockStatement(block: hbs.AST.BlockStatement): void;\n      PartialStatement(partial: hbs.AST.PartialStatement): void;\n      PartialBlockStatement(partial: hbs.AST.PartialBlockStatement): void;\n      DecoratorBlock(decorator: hbs.AST.DecoratorBlock): void;\n      Decorator(decorator: hbs.AST.Decorator): void;\n      MustacheStatement(mustache: hbs.AST.MustacheStatement): void;\n      ContentStatement(content: hbs.AST.ContentStatement): void;\n      CommentStatement(comment?: hbs.AST.CommentStatement): void;\n      SubExpression(sexpr: hbs.AST.SubExpression): void;\n      PathExpression(path: hbs.AST.PathExpression): void;\n      StringLiteral(str: hbs.AST.StringLiteral): void;\n      NumberLiteral(num: hbs.AST.NumberLiteral): void;\n      BooleanLiteral(bool: hbs.AST.BooleanLiteral): void;\n      UndefinedLiteral(): void;\n      NullLiteral(): void;\n      Hash(hash: hbs.AST.Hash): void;\n  }\n\n\n  export interface ResolvePartialOptions {\n    name: string;\n    helpers?: { [name: string]: Function };\n    partials?: { [name: string]: HandlebarsTemplateDelegate };\n    decorators?: { [name: string]: Function };\n    data?: any;\n  }\n\n  export namespace VM {\n    /**\n     * @deprecated\n     */\n    export function resolvePartial<T = any>(partial: HandlebarsTemplateDelegate<T> | undefined, context: any, options: ResolvePartialOptions): HandlebarsTemplateDelegate<T>;\n  }\n}\n\n/**\n* Implement this interface on your MVW/MVVM/MVC views such as Backbone.View\n**/\ninterface HandlebarsTemplatable {\n  template: HandlebarsTemplateDelegate;\n}\n\n// NOTE: for backward compatibility of this typing\ntype HandlebarsTemplateDelegate<T = any> = Handlebars.TemplateDelegate<T>;\n\ninterface HandlebarsTemplates {\n  [index: string]: HandlebarsTemplateDelegate;\n}\n\ninterface TemplateSpecification {\n\n}\n\n// for backward compatibility of this typing\ntype RuntimeOptions = Handlebars.RuntimeOptions;\n\ninterface CompileOptions {\n  data?: boolean;\n  compat?: boolean;\n  knownHelpers?: KnownHelpers;\n  knownHelpersOnly?: boolean;\n  noEscape?: boolean;\n  strict?: boolean;\n  assumeObjects?: boolean;\n  preventIndent?: boolean;\n  ignoreStandalone?: boolean;\n  explicitPartialContext?: boolean;\n}\n\ntype KnownHelpers = {\n  [name in BuiltinHelperName | CustomHelperName]: boolean;\n};\n\ntype BuiltinHelperName =\n  \"helperMissing\"|\n  \"blockHelperMissing\"|\n  \"each\"|\n  \"if\"|\n  \"unless\"|\n  \"with\"|\n  \"log\"|\n  \"lookup\";\n\ntype CustomHelperName = string;\n\ninterface PrecompileOptions extends CompileOptions {\n  srcName?: string;\n  destName?: string;\n}\n\ndeclare namespace hbs {\n  // for backward compatibility of this typing\n  type SafeString = Handlebars.SafeString;\n\n  type Utils = typeof Handlebars.Utils;\n}\n\ninterface Logger {\n  DEBUG: number;\n  INFO: number;\n  WARN: number;\n  ERROR: number;\n  level: number;\n\n  methodMap: { [level: number]: string };\n\n  log(level: number, obj: string): void;\n}\n\ntype CompilerInfo = [number/* revision */, string /* versions */];\n\ndeclare namespace hbs {\n  namespace AST {\n      interface Node {\n          type: string;\n          loc: SourceLocation;\n      }\n\n      interface SourceLocation {\n          source: string;\n          start: Position;\n          end: Position;\n      }\n\n      interface Position {\n          line: number;\n          column: number;\n      }\n\n      interface Program extends Node {\n          body: Statement[];\n          blockParams: string[];\n      }\n\n      interface Statement extends Node {}\n\n      interface MustacheStatement extends Statement {\n          type: 'MustacheStatement';\n          path: PathExpression | Literal;\n          params: Expression[];\n          hash: Hash;\n          escaped: boolean;\n          strip: StripFlags;\n      }\n\n      interface Decorator extends MustacheStatement { }\n\n      interface BlockStatement extends Statement {\n          type: 'BlockStatement';\n          path: PathExpression;\n          params: Expression[];\n          hash: Hash;\n          program: Program;\n          inverse: Program;\n          openStrip: StripFlags;\n          inverseStrip: StripFlags;\n          closeStrip: StripFlags;\n      }\n\n      interface DecoratorBlock extends BlockStatement { }\n\n      interface PartialStatement extends Statement {\n          type: 'PartialStatement';\n          name: PathExpression | SubExpression;\n          params: Expression[];\n          hash: Hash;\n          indent: string;\n          strip: StripFlags;\n      }\n\n      interface PartialBlockStatement extends Statement {\n          type: 'PartialBlockStatement';\n          name: PathExpression | SubExpression;\n          params: Expression[];\n          hash: Hash;\n          program: Program;\n          openStrip: StripFlags;\n          closeStrip: StripFlags;\n      }\n\n      interface ContentStatement extends Statement {\n          type: 'ContentStatement';\n          value: string;\n          original: StripFlags;\n      }\n\n      interface CommentStatement extends Statement {\n          type: 'CommentStatement';\n          value: string;\n          strip: StripFlags;\n      }\n\n      interface Expression extends Node {}\n\n      interface SubExpression extends Expression {\n          type: 'SubExpression';\n          path: PathExpression;\n          params: Expression[];\n          hash: Hash;\n      }\n\n      interface PathExpression extends Expression {\n          type: 'PathExpression';\n          data: boolean;\n          depth: number;\n          parts: string[];\n          original: string;\n      }\n\n      interface Literal extends Expression {}\n      interface StringLiteral extends Literal {\n          type: 'StringLiteral';\n          value: string;\n          original: string;\n      }\n\n      interface BooleanLiteral extends Literal {\n          type: 'BooleanLiteral';\n          value: boolean;\n          original: boolean;\n      }\n\n      interface NumberLiteral extends Literal {\n          type: 'NumberLiteral';\n          value: number;\n          original: number;\n      }\n\n      interface UndefinedLiteral extends Literal {\n          type: 'UndefinedLiteral';\n\t  }\n\n      interface NullLiteral extends Literal {\n          type: 'NullLiteral';\n\t  }\n\n      interface Hash extends Node {\n          type: 'Hash';\n          pairs: HashPair[];\n      }\n\n      interface HashPair extends Node {\n          type: 'HashPair';\n          key: string;\n          value: Expression;\n      }\n\n      interface StripFlags {\n          open: boolean;\n          close: boolean;\n      }\n\n      interface helpers {\n          helperExpression(node: Node): boolean;\n          scopeId(path: PathExpression): boolean;\n          simpleId(path: PathExpression): boolean;\n      }\n  }\n}\n\ndeclare module \"handlebars\" {\n  export = Handlebars;\n}\n\ndeclare module \"handlebars/runtime\" {\n  export = Handlebars;\n}\n"
    ]
  