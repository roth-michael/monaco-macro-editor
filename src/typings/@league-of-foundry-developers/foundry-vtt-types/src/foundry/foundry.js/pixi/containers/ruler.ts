
    export default [
      "@league-of-foundry-developers/foundry-vtt-types/src/foundry/foundry.js/pixi/containers/ruler.d.ts",
      "import { ConfiguredDocumentClass, ConfiguredObjectClassForName } from '../../../../types/helperTypes';\n\ndeclare global {\n  /**\n   * The Ruler - used to measure distances and trigger movements\n   */\n  class Ruler extends PIXI.Container {\n    /**\n     * @param user  - The User for whom to construct the Ruler instance\n     * @param color - (default: `null`)\n     */\n    constructor(\n      user?: InstanceType<ConfiguredDocumentClass<typeof User>> | null,\n      { color }?: { color?: number | null }\n    );\n\n    /**\n     * Record the User which this Ruler references\n     * @defaultValue `game.user`\n     */\n    user: InstanceType<ConfiguredDocumentClass<typeof User>>;\n\n    /**\n     * The ruler name - used to differentiate between players\n     * @defaultValue `Ruler.${user.id}`\n     */\n    name: string;\n\n    /**\n     * The ruler color - by default the color of the active user\n     * @defaultValue `foundry.utils.colorStringToHex(this.user.data.color) || 0x42F4E2`\n     */\n    color: number;\n\n    /**\n     * This Array tracks individual waypoints along the ruler's measured path.\n     * The first waypoint is always the origin of the route.\n     * @defaultValue `[]`\n     */\n    waypoints: PIXI.Point[];\n\n    /**\n     * The current destination point at the end of the measurement\n     * @defaultValue `null`\n     */\n    destination: PIXI.Point | null;\n\n    /**\n     * The Ruler element is a Graphics instance which draws the line and points of the measured path\n     */\n    ruler: PIXI.Graphics;\n\n    /**\n     * The Labels element is a Container of Text elements which label the measured path\n     */\n    labels: PIXI.Container;\n\n    /**\n     * Track the current measurement state\n     * @defaultValue `Ruler.STATES.INACTIVE`\n     */\n    protected _state: ValueOf<typeof Ruler['STATES']>;\n\n    /**\n     * An enumeration of the possible Ruler measurement states.\n     */\n    static STATES: {\n      INACTIVE: 0;\n      STARTING: 1;\n      MEASURING: 2;\n      MOVING: 3;\n    };\n\n    /**\n     * Is the Ruler being actively used to measure distance?\n     */\n    get active(): boolean;\n\n    /**\n     * Measure the distance between two points and render the ruler UI to illustrate it\n     * @param destination - The destination point to which to measure\n     * @param gridSpaces  - Restrict measurement only to grid spaces\n     *                      (default: `true`)\n     */\n    measure(\n      destination: Point,\n      { gridSpaces }?: { gridSpaces?: boolean }\n    ): {\n      ray: Ray;\n      label: PIXI.DisplayObject;\n    }[];\n\n    /**\n     * Get the text label for a segment of the measured path\n     */\n    protected _getSegmentLabel(segmentDistance: number, totalDistance: number, isTotal: boolean): string;\n\n    /**\n     * Highlight the measurement required to complete the move in the minimum number of discrete spaces\n     */\n    protected _highlightMeasurement(ray: Ray): void;\n\n    /**\n     * Determine whether a SPACE keypress event entails a legal token movement along a measured ruler\n     *\n     * @returns An indicator for whether a token was successfully moved or not. If True the event should be\n     *          prevented from propagating further, if False it should move on to other handlers.\n     */\n    moveToken(): Promise<false | undefined>;\n\n    /**\n     * Acquire a Token, if any, which is eligible to perform a movement based on the starting point of the Ruler\n     */\n    protected _getMovementToken(): InstanceType<ConfiguredObjectClassForName<'Token'>> | null | undefined;\n\n    /**\n     * A helper method to return an Array of Ray objects constructed from the waypoints of the measurement\n     * @param waypoints   - An Array of waypoint `{x, y}` Objects\n     * @param destination - An optional destination point to append to the existing waypoints\n     * @returns An Array of Ray objects which represent the segemnts of the waypoint path\n     */\n    protected _getRaysFromWaypoints(waypoints: PIXI.Point[], destination?: PIXI.Point): Ray[];\n\n    /**\n     * Clear display of the current Ruler\n     */\n    clear(): void;\n\n    /**\n     * Handle the beginning of a new Ruler measurement workflow\n     * @see Canvas._onDragLeftStart\n     */\n    protected _onDragStart(event: PIXI.InteractionEvent): void;\n\n    /**\n     * Handle left-click events on the Canvas during Ruler measurement.\n     * @see Canvas._onClickLeft\n     */\n    protected _onClickLeft(event: PIXI.InteractionEvent): void;\n\n    /**\n     * Handle right-click events on the Canvas during Ruler measurement.\n     * @see Canvas._onClickRight\n     */\n    protected _onClickRight(event: PIXI.InteractionEvent): boolean | void;\n\n    /**\n     * Continue a Ruler measurement workflow for left-mouse movements on the Canvas.\n     * @see Canvas._onDragLeftMove\n     */\n    protected _onMouseMove(event: PIXI.InteractionEvent): void;\n\n    /**\n     * Conclude a Ruler measurement workflow by releasing the left-mouse button.\n     * @see Canvas._onDragLeftDrop\n     */\n    protected _onMouseUp(event: PIXI.InteractionEvent): void;\n\n    /**\n     * Handle the addition of a new waypoint in the Ruler measurement path\n     * @remarks point is intentionally typed as Point because it is called with event.data.origin and only uses x and y\n     */\n    protected _addWaypoint(point: Point): void;\n\n    /**\n     * Handle the removal of a waypoint in the Ruler measurement path\n     * @param point - The current cursor position to snap to\n     * @param snap  - Snap exactly to grid spaces?\n     *                (default: `true`)\n     */\n    protected _removeWaypoint(point: PIXI.Point, { snap }?: { snap?: boolean }): void;\n\n    /**\n     * Handle the conclusion of a Ruler measurement workflow\n     */\n    protected _endMeasurement(): void;\n\n    toJSON(): {\n      class: 'Ruler';\n      name: string;\n      waypoints: Ruler['waypoints'];\n      destination: Ruler['destination'];\n      _state: Ruler['_state'];\n    };\n\n    /**\n     * Update a Ruler instance using data provided through the cursor activity socket\n     * @param data - Ruler data with which to update the display\n     */\n    update(data: ReturnType<Ruler['toJSON']>): void;\n  }\n}\n"
    ]
  